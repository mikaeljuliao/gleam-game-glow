[{"filePath":"C:\\Users\\nathanael\\jogo\\gleam-game-glow\\src\\game\\renderer.ts","messages":[{"ruleId":"prefer-const","severity":2,"message":"'socket' is never reassigned. Use 'const' instead.","line":1211,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":1211,"endColumn":15,"fix":{"range":[43106,43193],"text":"const socket = currentFrame.handSocket || (isBackFrame ? SOCKET_BACK_R : SOCKET_FRONT_R);"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1972,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1972,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[70318,70321],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[70318,70321],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-duplicate-case","severity":2,"message":"Duplicate case label.","line":2430,"column":5,"nodeType":"SwitchCase","messageId":"unexpected","endLine":2464,"endColumn":6},{"ruleId":"no-fallthrough","severity":2,"message":"Expected a 'break' statement before 'case'.","line":2430,"column":5,"nodeType":"SwitchCase","messageId":"case","endLine":2464,"endColumn":6},{"ruleId":"no-duplicate-case","severity":2,"message":"Duplicate case label.","line":2708,"column":5,"nodeType":"SwitchCase","messageId":"unexpected","endLine":2742,"endColumn":6},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2819,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2819,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[99395,99398],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[99395,99398],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"´╗┐import { PlayerState, EnemyState, ProjectileState, Particle, DungeonMap, DungeonRoom, Obstacle, ScreenEffect, Viewport, WeaponType, Portal, EssenceCore } from './types';\r\nimport { HiddenTrap } from './traps';\r\nimport * as C from './constants';\r\nimport { getBrightness } from './brightness';\r\nimport { getBiome, Biome } from './biomes';\r\nimport { roomKey, getCurrentRoom } from './dungeon';\r\n\r\n/** Draw text with letter-spacing by rendering each character individually */\r\nfunction drawSpacedText(ctx: CanvasRenderingContext2D, text: string, x: number, y: number, spacing: number, stroke = false) {\r\n  let cx = x;\r\n  const align = ctx.textAlign;\r\n  if (align === 'center') {\r\n    let totalW = 0;\r\n    for (const ch of text) totalW += ctx.measureText(ch).width + spacing;\r\n    totalW -= spacing;\r\n    cx = x - totalW / 2;\r\n  } else if (align === 'right') {\r\n    let totalW = 0;\r\n    for (const ch of text) totalW += ctx.measureText(ch).width + spacing;\r\n    totalW -= spacing;\r\n    cx = x - totalW;\r\n  }\r\n  const savedAlign = ctx.textAlign;\r\n  ctx.textAlign = 'left';\r\n  for (const ch of text) {\r\n    if (stroke) ctx.strokeText(ch, cx, y);\r\n    else ctx.fillText(ch, cx, y);\r\n    cx += ctx.measureText(ch).width + spacing;\r\n  }\r\n  ctx.textAlign = savedAlign;\r\n}\r\n\r\n/** Clean text: just color + letter spacing, no outline/shadow/glow */\r\nfunction drawHudText(ctx: CanvasRenderingContext2D, text: string, x: number, y: number, color: string, spacing = 0.8) {\r\n  ctx.fillStyle = color;\r\n  drawSpacedText(ctx, text, x, y, spacing, false);\r\n}\r\n\r\n// Render dungeon atmosphere in the viewport margins (beyond the 640x400 game area)\r\n// This fills the \"black bars\" with stone wall textures so the arena feels immersive\r\nexport function renderViewportMargins(ctx: CanvasRenderingContext2D, time: number, vp: Viewport, floor = 1) {\r\n  const { gox, goy, rw, rh } = vp;\r\n  const biome = getBiome(floor);\r\n\r\n  // 1. FILL BACKGROUND\r\n  ctx.fillStyle = biome.bgLayer2;\r\n  ctx.fillRect(-gox, -goy, rw, rh);\r\n\r\n  // 2. PARALLAX LAYER 2 (Furthest)\r\n  ctx.fillStyle = biome.bgLayer1;\r\n  const p2x = (-gox * 0.2) % 400;\r\n  const p2y = (-goy * 0.2) % 400;\r\n\r\n  for (let i = -1; i < Math.ceil(rw / 400) + 1; i++) {\r\n    const x = i * 400 + p2x - gox;\r\n    if (biome.theme === 'crystal') {\r\n      // Distant icy peaks\r\n      ctx.beginPath();\r\n      ctx.moveTo(x, rh - goy);\r\n      ctx.lineTo(x + 200, rh - goy - 150);\r\n      ctx.lineTo(x + 400, rh - goy);\r\n      ctx.fill();\r\n    } else if (biome.theme === 'volcano') {\r\n      // Volcanic ridges\r\n      ctx.beginPath();\r\n      ctx.moveTo(x, rh - goy);\r\n      ctx.quadraticCurveTo(x + 200, rh - goy - 200, x + 400, rh - goy);\r\n      ctx.fill();\r\n    } else {\r\n      // Forest silhouettes\r\n      ctx.fillRect(x + 50, rh - goy - 120, 30, 120);\r\n      ctx.beginPath();\r\n      ctx.arc(x + 65, rh - goy - 120, 50, 0, Math.PI * 2);\r\n      ctx.fill();\r\n    }\r\n  }\r\n\r\n  // 3. PARALLAX LAYER 1 (Walls / Pillars)\r\n  const ts = C.TILE_SIZE;\r\n  const startCol = Math.floor(-gox / ts) - 1;\r\n  const endCol = Math.ceil((rw - gox) / ts) + 1;\r\n  const startRow = Math.floor(-goy / ts) - 1;\r\n  const endRow = Math.ceil((rh - goy) / ts) + 1;\r\n\r\n  for (let row = startRow; row < endRow; row++) {\r\n    for (let col = startCol; col < endCol; col++) {\r\n      if (row >= 0 && row < C.dims.rr && col >= 0 && col < C.dims.rc) continue;\r\n\r\n      const x = col * ts;\r\n      const y = row * ts;\r\n      const hash = ((row * 7 + col * 13) & 0xFF);\r\n\r\n      // Main structural walls\r\n      ctx.fillStyle = biome.wall;\r\n      ctx.globalAlpha = 0.95 + (hash % 10) * 0.005;\r\n      ctx.fillRect(x, y, ts, ts);\r\n      ctx.globalAlpha = 1.0;\r\n\r\n      // Vertical Pillar Details\r\n      if (col % 6 === 0) {\r\n        ctx.fillStyle = biome.wallTop;\r\n        ctx.fillRect(x + 4, y, ts - 8, ts);\r\n        ctx.fillStyle = biome.wallDetail;\r\n        ctx.fillRect(x + 5, y, 1, ts);\r\n      }\r\n\r\n      // Biome decorative noise\r\n      if (hash % 15 === 0) {\r\n        ctx.fillStyle = biome.detail;\r\n        ctx.globalAlpha = 0.3;\r\n        ctx.beginPath();\r\n        ctx.arc(x + ts / 2, y + ts / 2, 8, 0, Math.PI * 2);\r\n        ctx.fill();\r\n        ctx.globalAlpha = 1.0;\r\n      }\r\n    }\r\n  }\r\n\r\n  // 4. GOD RAYS (Volumetric Light)\r\n  const rayAlpha = 0.05 + Math.sin(time * 0.4) * 0.02;\r\n  ctx.save();\r\n  ctx.globalCompositeOperation = 'screen';\r\n  for (let i = 0; i < 3; i++) {\r\n    const rX = ((time * 20 + i * 250) % (rw + 400)) - 200 - gox;\r\n    const rayGrad = ctx.createLinearGradient(rX, -goy, rX + 150, rh - goy);\r\n    rayGrad.addColorStop(0, biome.rays.replace('0.1', rayAlpha.toString()));\r\n    rayGrad.addColorStop(1, 'rgba(0,0,0,0)');\r\n\r\n    ctx.fillStyle = rayGrad;\r\n    ctx.beginPath();\r\n    ctx.moveTo(rX, -goy);\r\n    ctx.lineTo(rX + 80, -goy);\r\n    ctx.lineTo(rX + 250, rh - goy);\r\n    ctx.lineTo(rX + 150, rh - goy);\r\n    ctx.fill();\r\n  }\r\n  ctx.restore();\r\n\r\n  // 5. ATMOSPHERIC FOG\r\n  const fogGrad = ctx.createRadialGradient(C.dims.gw / 2, C.dims.gh / 2, 250, C.dims.gw / 2, C.dims.gh / 2, 700);\r\n  fogGrad.addColorStop(0, 'rgba(0,0,0,0)');\r\n  fogGrad.addColorStop(1, biome.fog);\r\n  ctx.fillStyle = fogGrad;\r\n  ctx.fillRect(-gox, -goy, rw, rh);\r\n}\r\nexport function renderFloor(ctx: CanvasRenderingContext2D, time: number, floor = 1) {\r\n  const biome = getBiome(floor);\r\n  const ts = C.TILE_SIZE;\r\n\r\n  // Render floor slabs (Large bricks/tiles)\r\n  for (let row = 0; row < C.dims.rr; row++) {\r\n    for (let col = 0; col < C.dims.rc; col++) {\r\n      const x = col * ts;\r\n      const y = row * ts;\r\n      const isEdge = row === 0 || row === C.dims.rr - 1 || col === 0 || col === C.dims.rc - 1;\r\n\r\n      if (isEdge) {\r\n        // SIDE WALLS & TOP TRIMS\r\n        const isTop = row === 0;\r\n        ctx.fillStyle = biome.wall;\r\n        ctx.fillRect(x, y, ts, ts);\r\n\r\n        // Top architectural face\r\n        if (isTop) {\r\n          ctx.fillStyle = biome.wallTop;\r\n          ctx.fillRect(x, y, ts, 12);\r\n          ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';\r\n          ctx.fillRect(x, y, ts, 1);\r\n        }\r\n\r\n        // Baseboard Light Bounce (Glow from floor onto wall base)\r\n        if (row === C.dims.rr - 1) {\r\n          const bounce = ctx.createLinearGradient(x, y + ts - 5, x, y + ts);\r\n          bounce.addColorStop(0, 'rgba(0,0,0,0)');\r\n          bounce.addColorStop(1, biome.accentGlow.replace('0.2', '0.1'));\r\n          ctx.fillStyle = bounce;\r\n          ctx.fillRect(x, y + ts - 5, ts, 5);\r\n        }\r\n      } else {\r\n        // SLABS\r\n        const slabCol = Math.floor(col / 3);\r\n        const slabRow = Math.floor(row / 2);\r\n        const slabID = (slabCol * 13 + slabRow * 7) % 100;\r\n\r\n        // Base color with painterly mottling\r\n        ctx.fillStyle = slabID % 2 === 0 ? biome.floor : biome.floorAlt;\r\n        ctx.fillRect(x, y, ts, ts);\r\n\r\n        // Subtle surface variations\r\n        const noise = (row * 31 + col * 17) % 6;\r\n        if (noise === 0) {\r\n          ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';\r\n          ctx.fillRect(x + 2, y + 2, ts - 4, ts - 4);\r\n        } else if (noise === 1) {\r\n          ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';\r\n          ctx.fillRect(x + 1, y + 1, ts - 2, 2);\r\n        }\r\n\r\n        // Seams\r\n        ctx.fillStyle = biome.seam;\r\n        if (col % 3 === 0) ctx.fillRect(x, y, 1, ts);\r\n        if (row % 2 === 0) ctx.fillRect(x, y, ts, 1);\r\n\r\n        // Biome Detail (Moss/Rust/Heat)\r\n        if (slabID % 23 === 0) {\r\n          ctx.fillStyle = biome.detail;\r\n          ctx.globalAlpha = 0.4;\r\n          ctx.fillRect(x + 2, y + ts - 6, ts - 4, 4);\r\n          ctx.globalAlpha = 1.0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Torches\r\n  const torchPositions: { x: number; y: number }[] = [];\r\n  for (let col = 4; col < C.dims.rc; col += 8) {\r\n    torchPositions.push({ x: col * C.TILE_SIZE, y: C.TILE_SIZE });\r\n    torchPositions.push({ x: col * C.TILE_SIZE, y: C.dims.gh - C.TILE_SIZE });\r\n  }\r\n  for (let row = 5; row < C.dims.rr; row += 5) {\r\n    torchPositions.push({ x: C.TILE_SIZE, y: row * C.TILE_SIZE });\r\n    torchPositions.push({ x: C.dims.gw - C.TILE_SIZE, y: row * C.TILE_SIZE });\r\n  }\r\n\r\n  const flicker = Math.sin(time * 8) * 0.1 + 0.9;\r\n  for (let ti = 0; ti < torchPositions.length; ti++) {\r\n    const t = torchPositions[ti];\r\n    const localFlicker = flicker * (1 + Math.sin(time * 10 + ti) * 0.1);\r\n\r\n    // Glow pool\r\n    const floorGlow = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, 70);\r\n    floorGlow.addColorStop(0, biome.accentGlow.replace('0.2', (0.15 * localFlicker).toString()));\r\n    floorGlow.addColorStop(1, 'rgba(0,0,0,0)');\r\n    ctx.fillStyle = floorGlow;\r\n    ctx.fillRect(t.x - 70, t.y - 70, 140, 140);\r\n\r\n    // Flame Core\r\n    ctx.fillStyle = biome.accent;\r\n    ctx.shadowBlur = 10;\r\n    ctx.shadowColor = biome.accent;\r\n    ctx.beginPath();\r\n    const fSway = Math.sin(time * 12 + ti) * 2;\r\n    ctx.moveTo(t.x - 2 + fSway * 0.5, t.y);\r\n    ctx.quadraticCurveTo(t.x + fSway, t.y - 10, t.x + fSway * 0.2, t.y);\r\n    ctx.fill();\r\n    ctx.shadowBlur = 0;\r\n\r\n    // Handle\r\n    ctx.fillStyle = biome.wallDetail;\r\n    ctx.fillRect(t.x - 1, t.y - 2, 2, 10);\r\n  }\r\n}\r\n\r\n/**\r\n * Render a Dimensional Rift (Fenda Dimensional) Door visual\r\n * This replaces the standard door sprite but maintains same logic.\r\n */\r\nfunction renderDimensionalFissure(ctx: CanvasRenderingContext2D, cx: number, cy: number, time: number, isOpen: boolean, color: string, px?: number, py?: number) {\r\n  const dx = px !== undefined ? px - cx : 1000;\r\n  const dy = py !== undefined ? py - cy : 1000;\r\n  const dist = Math.sqrt(dx * dx + dy * dy);\r\n\r\n  // Proximity expansion: 1.1x scale if within 85 units\r\n  const proximityScale = dist < 85 ? 1.1 : 1.0;\r\n\r\n  const pulse = Math.sin(time * 3) * 0.1 + 0.95;\r\n  const alpha = isOpen ? 0.45 * pulse : 0.15;\r\n\r\n  ctx.save();\r\n  ctx.translate(cx, cy);\r\n  ctx.scale(proximityScale, proximityScale);\r\n\r\n  // 1. Atmospheric Glow - Roxo Elegante (Deep Mystic Purple)\r\n  // Intensified for better distance reading\r\n  const glowGrad = ctx.createRadialGradient(0, 0, 5, 0, 0, 30);\r\n  glowGrad.addColorStop(0, `rgba(${color}, ${alpha})`);\r\n  glowGrad.addColorStop(1, 'rgba(0,0,0,0)');\r\n  ctx.fillStyle = glowGrad;\r\n  ctx.beginPath();\r\n  ctx.ellipse(0, 0, 24 * pulse, 35 * pulse, 0, 0, Math.PI * 2);\r\n  ctx.fill();\r\n\r\n  // 2. The Rift Void (Irregular vertical fissure)\r\n  // Centro preto profundo\r\n  ctx.fillStyle = '#010003';\r\n  ctx.beginPath();\r\n\r\n  const freq = time * 2.5;\r\n  const h = 26 * (isOpen ? pulse : 0.85);\r\n  const w = isOpen ? 16 : 4.5; // Wider rift to accommodate player size visually\r\n\r\n  ctx.moveTo(0, -h);\r\n  for (let i = -h; i <= h; i += 4) {\r\n    const taper = 1 - Math.pow(i / h, 2);\r\n    const noise = Math.sin(freq + i * 0.45) * 3;\r\n    ctx.lineTo((w + noise) * taper, i);\r\n  }\r\n  for (let i = h; i >= -h; i -= 4) {\r\n    const taper = 1 - Math.pow(i / h, 2);\r\n    const noise = Math.sin(freq * 1.3 - i * 0.5) * 3;\r\n    ctx.lineTo((-w + noise) * taper, i);\r\n  }\r\n  ctx.closePath();\r\n  ctx.fill();\r\n\r\n  // 3. Shimmering Border (Bordas roxo escuro elegante)\r\n  // Thicker stroke for better visibility\r\n  ctx.strokeStyle = `rgba(160, 80, 255, ${isOpen ? 0.6 * pulse : 0.25})`;\r\n  ctx.lineWidth = 1.8;\r\n  ctx.stroke();\r\n\r\n  ctx.restore();\r\n}\r\n\r\nexport function renderDoors(ctx: CanvasRenderingContext2D, room: DungeonRoom, time: number, doorsLocked: boolean = false, dungeon?: DungeonMap, px?: number, py?: number) {\r\n  const midX = C.dims.gw / 2;\r\n  const midY = C.dims.gh / 2;\r\n  const dw = C.DOOR_WIDTH;\r\n  const isOpen = room.cleared && !doorsLocked;\r\n  const pulse = Math.sin(time * 4) * 0.3 + 0.7;\r\n\r\n  // Helper to check if a neighboring room has been visited\r\n  const isNeighborVisited = (dir: 'north' | 'south' | 'east' | 'west'): boolean => {\r\n    if (!dungeon) return true;\r\n    let nx = room.gridX, ny = room.gridY;\r\n    if (dir === 'north') ny--;\r\n    else if (dir === 'south') ny++;\r\n    else if (dir === 'west') nx--;\r\n    else if (dir === 'east') nx++;\r\n    const key = roomKey(nx, ny);\r\n    const neighbor = dungeon.rooms.get(key);\r\n    return neighbor ? neighbor.visited : false;\r\n  };\r\n\r\n  const drawDoor = (x: number, y: number, w: number, h: number, dir: 'north' | 'south' | 'east' | 'west') => {\r\n    const cx = x + w / 2;\r\n    const cy = y + h / 2;\r\n\r\n    // Door Logic remains intact, but Visual is now a Dimensional Rift\r\n    const visited = isOpen ? isNeighborVisited(dir) : false;\r\n    const riftColor = visited ? '120, 60, 200' : '60, 0, 120'; // Slightly brighter and higher contrast\r\n\r\n    renderDimensionalFissure(ctx, cx, cy, time, isOpen, riftColor, px, py);\r\n\r\n    if (isOpen) {\r\n      if (visited) {\r\n        // GREEN Label ÔÇö already visited room\r\n        ctx.fillStyle = `rgba(50, 255, 100, ${0.7 * pulse})`;\r\n        ctx.font = `500 7px ${C.HUD_FONT}`;\r\n        ctx.textAlign = 'center';\r\n        if (dir === 'north') ctx.fillText('VISITADA', cx, y + C.TILE_SIZE + 14);\r\n        else if (dir === 'south') ctx.fillText('VISITADA', cx, y - 6);\r\n        else if (dir === 'west') ctx.fillText('VISITADA', x + C.TILE_SIZE + 28, cy + 3);\r\n        else ctx.fillText('VISITADA', x - 28, cy + 3);\r\n        ctx.textAlign = 'left';\r\n      } else {\r\n        // ORANGE Label ÔÇö unexplored room\r\n        ctx.fillStyle = `rgba(255, 180, 30, ${0.85 * pulse})`;\r\n        ctx.font = `500 8px ${C.HUD_FONT}`;\r\n        ctx.textAlign = 'center';\r\n        if (dir === 'north') ctx.fillText('? EXPLORAR ?', cx, y + C.TILE_SIZE + 16);\r\n        else if (dir === 'south') ctx.fillText('? EXPLORAR ?', cx, y - 8);\r\n        else if (dir === 'west') ctx.fillText('? EXPLORAR', x + C.TILE_SIZE + 28, cy + 3);\r\n        else ctx.fillText('EXPLORAR ?', x - 36, cy + 3);\r\n        ctx.textAlign = 'left';\r\n      }\r\n    } else {\r\n      // Locked Interaction Labels\r\n      ctx.fillStyle = 'rgba(150, 60, 60, 0.5)';\r\n      ctx.font = `6px ${C.HUD_FONT}`;\r\n      ctx.textAlign = 'center';\r\n      if (dir === 'north') ctx.fillText('TRANCADA', cx, y + C.TILE_SIZE + 12);\r\n      else if (dir === 'south') ctx.fillText('TRANCADA', cx, y - 4);\r\n      else if (dir === 'west') ctx.fillText('TRANCADA', x + C.TILE_SIZE + 30, cy + 3);\r\n      else ctx.fillText('TRANCADA', x - 30, cy + 3);\r\n      ctx.textAlign = 'left';\r\n    }\r\n  };\r\n\r\n  if (room.doors.north) drawDoor(midX - dw / 2, 0, dw, C.TILE_SIZE, 'north');\r\n  if (room.doors.south) drawDoor(midX - dw / 2, C.dims.gh - C.TILE_SIZE, dw, C.TILE_SIZE, 'south');\r\n  if (room.doors.west) drawDoor(0, midY - dw / 2, C.TILE_SIZE, dw, 'west');\r\n  if (room.doors.east) drawDoor(C.dims.gw - C.TILE_SIZE, midY - dw / 2, C.TILE_SIZE, dw, 'east');\r\n}\r\n\r\nexport function renderObstacles(ctx: CanvasRenderingContext2D, obstacles: Obstacle[], floor = 1) {\r\n  const biome = getBiome(floor);\r\n  const time = Date.now() / 1000;\r\n\r\n  for (const o of obstacles) {\r\n    const hash = ((o.x * 7 + o.y * 13) & 0xFF);\r\n\r\n    // 0. AMBIENT OCCLUSION (Soft floor shadow at base only)\r\n    const aoGrad = ctx.createRadialGradient(o.x + o.w / 2, o.y + o.h / 2, 2, o.x + o.w / 2, o.y + o.h / 2, Math.max(o.w, o.h) * 1.5);\r\n    aoGrad.addColorStop(0, 'rgba(0,0,0,0.6)');\r\n    aoGrad.addColorStop(1, 'rgba(0,0,0,0)');\r\n    ctx.fillStyle = aoGrad;\r\n    ctx.fillRect(o.x - 10, o.y - 10, o.w + 20, o.h + 20);\r\n\r\n    // 1. BIOME HERO SILHOUETTE\r\n    ctx.save();\r\n    ctx.beginPath();\r\n\r\n    if (biome.theme === 'forest') {\r\n      const steps = 16;\r\n      for (let i = 0; i <= steps; i++) {\r\n        const angle = (i / steps) * Math.PI * 2;\r\n        const drift = Math.sin(angle * 4 + hash) * 6;\r\n        const r = o.w / 2 + drift;\r\n        const px = o.x + o.w / 2 + Math.cos(angle) * r;\r\n        const py = o.y + o.h / 2 + Math.sin(angle) * r;\r\n        if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);\r\n      }\r\n    } else if (biome.theme === 'crystal') {\r\n      const pts = [\r\n        [o.x + 4, o.y - 4], [o.x + o.w - 2, o.y + 2],\r\n        [o.x + o.w + 6, o.y + o.h * 0.4], [o.x + o.w + 2, o.y + o.h + 4],\r\n        [o.x + 2, o.y + o.h], [o.x - 4, o.y + o.h * 0.5]\r\n      ];\r\n      ctx.moveTo(pts[0][0], pts[0][1]);\r\n      pts.forEach(p => ctx.lineTo(p[0], p[1]));\r\n    } else {\r\n      ctx.moveTo(o.x, o.y);\r\n      ctx.lineTo(o.x + o.w + 4, o.y - 2);\r\n      ctx.lineTo(o.x + o.w + 2, o.y + o.h + 4);\r\n      ctx.lineTo(o.x - 4, o.y + o.h + 2);\r\n    }\r\n    ctx.closePath();\r\n    ctx.clip();\r\n\r\n    // 2. PAINTERLY BASE LAYERING\r\n    ctx.fillStyle = biome.wall;\r\n    ctx.fillRect(o.x - 10, o.y - 10, o.w + 20, o.h + 20);\r\n\r\n    // Layered texture noise\r\n    for (let i = 0; i < 3; i++) {\r\n      ctx.fillStyle = i % 2 === 0 ? 'rgba(0,0,0,0.1)' : 'rgba(255,255,255,0.05)';\r\n      const tx = o.x + (hash * (i + 1)) % o.w;\r\n      const ty = o.y + (hash * (i + 2)) % o.h;\r\n      ctx.fillRect(tx, ty, 20, 20);\r\n    }\r\n\r\n    // 3. SPECIALIZED BIOME ELEMENTS\r\n    if (biome.theme === 'forest') {\r\n      // DENSE LEAVES CLUSTERS\r\n      const leafColors = [\"#1a3a1a\", \"#2a5a27\", \"#4a8a3b\"];\r\n      for (let i = 0; i < 8; i++) {\r\n        const lx = o.x + ((hash * (i + 7)) % o.w);\r\n        const ly = o.y + ((hash * (i + 4)) % o.h);\r\n        const r = 10 + (i % 3) * 4;\r\n\r\n        ctx.fillStyle = leafColors[i % 3];\r\n        ctx.beginPath();\r\n        for (let j = 0; j < 6; j++) {\r\n          const a = j * Math.PI / 3;\r\n          const lr = r * (0.8 + Math.sin(a * 3) * 0.2);\r\n          ctx.lineTo(lx + Math.cos(a) * lr, ly + Math.sin(a) * lr);\r\n        }\r\n        ctx.fill();\r\n\r\n        // Leaf stroke for definition\r\n        ctx.strokeStyle = \"rgba(0,0,0,0.2)\";\r\n        ctx.lineWidth = 0.5;\r\n        ctx.stroke();\r\n      }\r\n      // Hanging Ivy\r\n      ctx.strokeStyle = \"#1a3a1a\";\r\n      ctx.lineWidth = 2;\r\n      ctx.beginPath();\r\n      ctx.moveTo(o.x + o.w * 0.4, o.y);\r\n      ctx.quadraticCurveTo(o.x + o.w * 0.1, o.y + o.h * 0.5, o.x + o.w * 0.3, o.y + o.h + 10);\r\n      ctx.stroke();\r\n    }\r\n    else if (biome.theme === 'crystal') {\r\n      // FACETED CRYSTALS\r\n      for (let i = 0; i < 4; i++) {\r\n        const cx = o.x + (o.w * 0.2) + (i * 12);\r\n        const cy = o.y + (o.h * 0.2) + (i * 8);\r\n\r\n        // Inner Refraction Gradient\r\n        const cGrad = ctx.createLinearGradient(cx, cy - 10, cx + 10, cy + 20);\r\n        cGrad.addColorStop(0, \"#ffffff\");\r\n        cGrad.addColorStop(0.3, biome.accent);\r\n        cGrad.addColorStop(1, \"#0a1a3a\");\r\n\r\n        ctx.fillStyle = cGrad;\r\n        ctx.beginPath();\r\n        ctx.moveTo(cx, cy);\r\n        ctx.lineTo(cx + 15, cy - 20);\r\n        ctx.lineTo(cx + 25, cy);\r\n        ctx.lineTo(cx + 12, cy + 30);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n\r\n        // Shine Glint\r\n        ctx.fillStyle = \"rgba(255,255,255,0.4)\";\r\n        ctx.fillRect(cx + 8, cy - 8, 2, 8);\r\n      }\r\n    }\r\n    else if (biome.theme === 'volcano') {\r\n      // MAGMA CORE & WEBS\r\n      const glow = 0.7 + Math.sin(time * 5 + hash) * 0.3;\r\n      ctx.shadowBlur = 10 * glow;\r\n      ctx.shadowColor = \"#ff2200\";\r\n\r\n      // Vein System\r\n      ctx.strokeStyle = \"#ff4400\";\r\n      ctx.lineWidth = 5;\r\n      ctx.beginPath();\r\n      ctx.moveTo(o.x - 5, o.y + o.h * 0.4);\r\n      ctx.bezierCurveTo(o.x + o.w * 0.4, o.y + o.h * 0.1, o.x + o.w * 0.6, o.y + o.h * 0.9, o.x + o.w + 5, o.y + o.h * 0.6);\r\n      ctx.stroke();\r\n\r\n      // White-Hot Core\r\n      ctx.strokeStyle = \"#fffbea\";\r\n      ctx.lineWidth = 1.5;\r\n      ctx.stroke();\r\n\r\n      ctx.shadowBlur = 0;\r\n\r\n      // Bubbling Detail\r\n      ctx.fillStyle = \"rgba(255, 120, 0, 0.4)\";\r\n      for (let i = 0; i < 4; i++) {\r\n        const bx = o.x + (hash * i) % o.w;\r\n        const by = o.y + (hash + i) % o.h;\r\n        ctx.beginPath();\r\n        ctx.arc(bx, by, 3 * glow, 0, Math.PI * 2);\r\n        ctx.fill();\r\n      }\r\n    }\r\n\r\n    // 4. GLOBAL ILLUMINATION (Post-Clip)\r\n    ctx.restore();\r\n\r\n    // Directional Rim Highlight (Top-Left Light Source)\r\n    ctx.strokeStyle = \"rgba(255,255,255,0.25)\";\r\n    ctx.lineWidth = 1.5;\r\n    ctx.beginPath();\r\n    ctx.moveTo(o.x, o.y + o.h);\r\n    ctx.lineTo(o.x, o.y);\r\n    ctx.lineTo(o.x + o.w, o.y);\r\n    ctx.stroke();\r\n\r\n    // Biome Wash (Tint everything slightly with god-ray color)\r\n    ctx.fillStyle = biome.rays.replace('0.1', '0.05');\r\n    ctx.globalCompositeOperation = 'soft-light';\r\n    ctx.fillRect(o.x, o.y, o.w, o.h);\r\n    ctx.globalCompositeOperation = 'source-over';\r\n  }\r\n}\r\n\r\nexport function renderPlayer(ctx: CanvasRenderingContext2D, p: PlayerState, time: number) {\r\n  const visible = p.invincibleTime <= 0 || Math.floor(p.invincibleTime * 20) % 2 === 0;\r\n  if (!visible) return;\r\n\r\n  // === ATTACK ANIMATION STATE ===\r\n  let animX = 0;\r\n  let animY = 0;\r\n  let bodyRot = 0;\r\n\r\n  if (p.meleeAttacking) {\r\n    const activeStep = p.activeComboStep || 1;\r\n    const isFinalHit = activeStep === 4;\r\n    const isHeavyHit = activeStep === 3;\r\n    const duration = C.MELEE_COOLDOWN * (isFinalHit ? 1.5 : 1.0);\r\n    const t = 1 - (p.meleeTimer / duration);\r\n\r\n    const fx = p.facing.x;\r\n    const fy = p.facing.y;\r\n\r\n    let lunge = 0;\r\n\r\n    if (activeStep === 1) {\r\n      // Step 1: Snap Forward (Lean In)\r\n      if (t < 0.2) { lunge = -2 * (t / 0.2); bodyRot = -0.1 * (t / 0.2); } // Windup\r\n      else if (t < 0.6) { lunge = 6; bodyRot = 0.2; } // Strike\r\n      else { const rt = (t - 0.6) / 0.4; lunge = 6 * (1 - rt); bodyRot = 0.2 * (1 - rt); }\r\n    }\r\n    else if (activeStep === 2) {\r\n      // Step 2: Backhand (Twist Back)\r\n      if (t < 0.2) { lunge = 2; bodyRot = 0.1; }\r\n      else if (t < 0.6) { lunge = 5; bodyRot = -0.15; }\r\n      else { lunge = 5 * (1 - (t - 0.6) / 0.4); bodyRot = 0; }\r\n    }\r\n    else if (activeStep === 3) {\r\n      // Step 3: Heavy Smash (Deep crouch -> Big Lunge)\r\n      if (t < 0.3) { lunge = -3; animY = 2; bodyRot = -0.1; } // Crouch\r\n      else if (t < 0.6) { lunge = 12; animY = -3; bodyRot = 0.3; } // Jump Lunge\r\n      else { lunge = 12 * (1 - (t - 0.6) / 0.4); animY = 0; bodyRot = 0.1; }\r\n    }\r\n    else {\r\n      // Step 4: Vortex (Spin/Wobble)\r\n      const spin = Math.sin(t * Math.PI * 4);\r\n      lunge = 8 + spin * 2;\r\n      bodyRot = spin * 0.1;\r\n      animX += Math.cos(t * Math.PI * 8) * 2;\r\n    }\r\n\r\n    animX += fx * lunge;\r\n    animY += fy * lunge;\r\n  }\r\n\r\n  const x = p.x + animX;\r\n  const y = p.y + animY;\r\n  // Effects disabled ÔÇö pure sprite visualisation mode\r\n  // drawAmbientEffects(ctx, p, x, y, time);\r\n\r\n  // Magic channeling effect (Free hand)\r\n  HandCastEffect.render(ctx, p, time);\r\n\r\n  // 2. Pose Selection\r\n  if (p.meleeAttacking) {\r\n    const step = p.activeComboStep || 1;\r\n    const isFinal = step === 4;\r\n    const duration = C.MELEE_COOLDOWN * (isFinal ? 1.5 : 1.0);\r\n    const progress = 1 - (p.meleeTimer / duration);\r\n\r\n    if (step === 1) drawAttackPose1(ctx, p, x, y, time, progress);\r\n    else if (step === 2) drawAttackPose2(ctx, p, x, y, time, progress);\r\n    else if (step === 3) drawAttackPose3(ctx, p, x, y, time, progress);\r\n    else drawAttackPose4(ctx, p, x, y, time, progress);\r\n  } else {\r\n    drawIdleRunPose(ctx, p, x, y, time);\r\n  }\r\n}\r\n\r\n\r\n\r\nfunction drawAmbientEffects(_ctx: CanvasRenderingContext2D, _p: PlayerState, _x: number, _y: number, _time: number) {\r\n  // All effects removed ÔÇö pure sprite visualisation mode.\r\n}\r\n\r\n\r\n\r\n\r\n// ============================================================\r\n// PLAYER SPRITE ÔÇö OFFICIAL CHARACTER ASSET\r\n// ============================================================\r\n// Body rendered via ctx.drawImage() only. Canvas = zero effects.\r\n// ============================================================\r\n\r\n// ÔöÇÔöÇ Types ÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇ\r\ntype SpriteDir = 'down' | 'up' | 'left' | 'right'\r\n  | 'down-left' | 'down-right' | 'up-left' | 'up-right';\r\n\r\ninterface SpriteFrame {\r\n  src: string;\r\n  fallback?: boolean;\r\n  flipX?: boolean;\r\n  vOffset?: number; // Offset vertical espec├¡fico para cada frame (corre├º├úo de \"pulo\")\r\n  scaleMult?: number; // Ajuste fino de tamanho por frame\r\n  // Ponto exato onde a m├úo estaria na imagem (relativo ao centro/piv├┤ do sprite)\r\n  handSocket?: { x: number; y: number };\r\n}\r\n\r\n// ÔöÇÔöÇ 8-Direction Sprite Map ÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇ\r\n// Drop the PNG in /public and set fallback: false to activate a direction.\r\n// At├® termos a arte final, apontamos para 'main_character_idle.png'\r\n// Socket coordinates values (calibrados estruturalmente para as artes 80x80)\r\nconst SOCKET_FRONT_L = { x: -16, y: -26 };\r\nconst SOCKET_FRONT_R = { x: 16, y: -26 };\r\nconst SOCKET_BACK_L = { x: -14, y: -30 }; // Subido para encaixe perfeito\r\nconst SOCKET_BACK_R = { x: 14, y: -30 };\r\nconst SOCKET_SIDE = { x: -2, y: -26 };\r\n\r\nconst SPRITE_FRAMES: Record<SpriteDir | 'idle-cycle', SpriteFrame | SpriteFrame[]> = {\r\n  'down': [\r\n    { src: '/player-andando-de-frente1.png', handSocket: SOCKET_FRONT_R, vOffset: 0, scaleMult: 0.8 },\r\n    { src: '/player-andando-de-frente-2.png', handSocket: SOCKET_FRONT_R, vOffset: 0, scaleMult: 0.8 },\r\n  ],\r\n  'up': [\r\n    { src: '/player-de-costa-1.png', handSocket: SOCKET_BACK_R, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-de-costa-2.png', handSocket: SOCKET_BACK_R, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-de-costa-3.png', handSocket: SOCKET_BACK_R, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-de-costa-4.png', handSocket: SOCKET_BACK_R, vOffset: 0, scaleMult: 1.0 },\r\n  ],\r\n  'idle-cycle': [\r\n    { src: '/player-parado-1.png', handSocket: SOCKET_FRONT_R, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-parado-2a.png', handSocket: SOCKET_FRONT_R, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-parado-3a.png', handSocket: SOCKET_FRONT_R, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-parado-4aa.png', handSocket: SOCKET_FRONT_R, vOffset: 0, scaleMult: 1.0 },\r\n  ],\r\n  'right': [\r\n    { src: '/player-de-lado-1.png', handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-de-lado-2.png', handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-de-lado-3.png', handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-de-lado-4.png', handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n  ],\r\n  'left': [\r\n    { src: '/player-de-lado-1.png', flipX: true, handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-de-lado-2.png', flipX: true, handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-de-lado-3.png', flipX: true, handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-de-lado-4.png', flipX: true, handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n  ],\r\n  'down-right': [\r\n    { src: '/player-de-lado-1.png', handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-de-lado-2.png', handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-de-lado-3.png', handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-de-lado-4.png', handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n  ],\r\n  'down-left': [\r\n    { src: '/player-de-lado-1.png', flipX: true, handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-de-lado-2.png', flipX: true, handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-de-lado-3.png', flipX: true, handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-de-lado-4.png', flipX: true, handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n  ],\r\n  'up-right': [\r\n    { src: '/player-de-lado-1.png', handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-de-lado-2.png', handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-de-lado-3.png', handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-de-lado-4.png', handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n  ],\r\n  'up-left': [\r\n    { src: '/player-de-lado-1.png', flipX: true, handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-de-lado-2.png', flipX: true, handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-de-lado-3.png', flipX: true, handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n    { src: '/player-de-lado-4.png', flipX: true, handSocket: SOCKET_SIDE, vOffset: 0, scaleMult: 1.0 },\r\n  ],\r\n};\r\n\r\n// ÔöÇÔöÇ Constants ÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇ\r\nconst SPRITE_SIZE = 80;               // Size in game units (slightly larger for the ears)\r\nconst PIVOT_X = SPRITE_SIZE / 2;  // horizontal anchor\r\nconst PIVOT_Y = SPRITE_SIZE * 0.55; // Lower pivot to account for large ears/head\r\nconst WEAPON_HAND_Y = -38;        // Altura do peito/ombro para as armas\r\nconst WEAPON_HAND_BASE_X = 18;    // Espa├ºamento das m├úos (ombro a ombro)\r\n\r\n// ÔöÇÔöÇ Sprite Cache & Loader ÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇ\r\nconst _loadedSprites: Record<string, HTMLImageElement> = {};\r\nfunction getSprite(src: string): HTMLImageElement {\r\n  if (!_loadedSprites[src]) {\r\n    const img = new Image();\r\n    img.src = src;\r\n    _loadedSprites[src] = img;\r\n  }\r\n  return _loadedSprites[src];\r\n}\r\n\r\n// Pre-load idle sprite on module init\r\nconst initialFrame = SPRITE_FRAMES['down'];\r\nconst initialSrc = Array.isArray(initialFrame) ? initialFrame[0].src : initialFrame.src;\r\ngetSprite(initialSrc);\r\n\r\n// ÔöÇÔöÇ Direction Selector ÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇ\r\n// Update helper to handle idle and vertical preference\r\nfunction getSpriteFrameForFacing(p: PlayerState): SpriteFrame | SpriteFrame[] {\r\n  const fx = p.facing.x;\r\n  const fy = p.facing.y;\r\n  const isMoving = p.isMoving || p.isDashing || p.meleeAttacking;\r\n\r\n  // Se parado e N├âO estiver atacando, usa o ciclo de anima├º├úo parado\r\n  if (!isMoving) {\r\n    return SPRITE_FRAMES['idle-cycle'];\r\n  }\r\n\r\n  // Prioridade Vertical (Costas/Frente)\r\n  if (Math.abs(fy) > Math.abs(fx) * 1.5) {\r\n    if (fy < 0) return SPRITE_FRAMES['up'];\r\n    if (fy > 0) return SPRITE_FRAMES['down'];\r\n  }\r\n\r\n  // Diagonais e Lados\r\n  if (fx < 0) return SPRITE_FRAMES['left'];\r\n  if (fx > 0) return SPRITE_FRAMES['right'];\r\n\r\n  return SPRITE_FRAMES['down']; // Fallback\r\n}\r\n\r\n// ÔöÇÔöÇ Main Draw Function ÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇ\r\n/**\r\n * Render the official player character.\r\n * Body: ctx.drawImage ONLY.\r\n */\r\nexport function renderPlayerSprite(ctx: CanvasRenderingContext2D, p: PlayerState, time: number) {\r\n  const frameOrFrames = getSpriteFrameForFacing(p);\r\n\r\n  // Usar a flag expl├¡cita do PlayerState\r\n  const isMoving = p.isMoving || p.isDashing;\r\n  const isIdleCycle = !isMoving;\r\n\r\n  let frame: SpriteFrame;\r\n  if (Array.isArray(frameOrFrames)) {\r\n    if (isMoving || isIdleCycle) {\r\n      // Ajuste de velocidade da anima├º├úo (Idle muito sutil, Run normal)\r\n      const animSpeed = isIdleCycle ? 1.2 : 10;\r\n      const index = Math.floor(time * animSpeed) % frameOrFrames.length;\r\n      frame = frameOrFrames[index];\r\n    } else {\r\n      frame = frameOrFrames[0];\r\n    }\r\n  } else {\r\n    frame = frameOrFrames;\r\n  }\r\n\r\n  if (!frame) frame = { src: '/player-de-frente.png' };\r\n\r\n  const flipX = frame.flipX === true;\r\n  const src = frame.src || '/player-de-frente.png';\r\n  const sprite = getSprite(src);\r\n\r\n  if (sprite.complete && sprite.naturalWidth !== 0) {\r\n    ctx.save();\r\n    ctx.imageSmoothingEnabled = true;\r\n    ctx.imageSmoothingQuality = 'high';\r\n\r\n    // Normaliza├º├úo Universal: For├ºa todos os sprites a serem pequenos e uniformes (Base 72)\r\n    const baseTargetHeight = 64; // Reduzido de 72 para 64 (pedido do user)\r\n    const frameScale = frame.scaleMult || 1.0;\r\n    const h = baseTargetHeight * frameScale;\r\n\r\n    // Normaliza├º├úo pela Altura: Mais est├ível para manter o tamanho da cabe├ºa/corpo consistente\r\n    const scale = h / Math.max(sprite.naturalHeight, 1);\r\n    const w = sprite.naturalWidth * scale;\r\n\r\n    // Compensa├º├úo Grounded Limpa: Sem offsets individuais para evitar jumper\r\n    const finalYOffset = 0;\r\n\r\n    if (flipX) {\r\n      ctx.scale(-1, 1);\r\n      ctx.drawImage(sprite, -w / 2, -h + finalYOffset, w, h);\r\n    } else {\r\n      ctx.drawImage(sprite, -w / 2, -h + finalYOffset, w, h);\r\n    }\r\n\r\n    ctx.restore();\r\n  } else {\r\n    // Visibility guard: Show a simple shape if assets are missing/loading\r\n    ctx.save();\r\n    // Head shape\r\n    ctx.fillStyle = '#08080c';\r\n    ctx.beginPath();\r\n    ctx.arc(0, -45, 12, 0, Math.PI * 2);\r\n    ctx.fill();\r\n    // Body shape\r\n    ctx.fillRect(-10, -35, 20, 30);\r\n    ctx.restore();\r\n  }\r\n}\r\n\r\nfunction drawOriginalCharacterBody(ctx: CanvasRenderingContext2D, p: PlayerState, time: number) {\r\n  renderPlayerSprite(ctx, p, time);\r\n}\r\n\r\n\r\n// OLD (Hyper-Detailed) - Disabled\r\n/* function drawOriginalCharacterBody_OLD(ctx: CanvasRenderingContext2D, p: PlayerState, time: number, lookX: number, hoodShift: number, breathe: number, walkCycle: number = 0, tilt: number = 0) {\r\n\r\n\r\n  // Palette (Darker, richer, higher contrast)\r\n  const C_BASE_DARK = '#08080c';\r\n  const C_BASE_MID = '#12121a';\r\n  const C_BASE_LIGHT = '#202030'; // Highlight base\r\n  const C_RIM_LIGHT = 'rgba(180, 220, 255, 0.5)'; // Sharp rim\r\n  const C_ACCENT_CYAN = 'rgba(0, 255, 255, 0.2)';\r\n\r\n  // Helpers\r\n  const grad = (x1: number, y1: number, x2: number, y2: number, c1: string, c2: string) => {\r\n    const g = ctx.createLinearGradient(x1, y1, x2, y2);\r\n    g.addColorStop(0, c1);\r\n    g.addColorStop(1, c2);\r\n    return g;\r\n  };\r\n\r\n  const gRadial = (x: number, y: number, r: number, c1: string, c2: string) => {\r\n    const g = ctx.createRadialGradient(x, y, 0, x, y, r);\r\n    g.addColorStop(0, c1);\r\n    g.addColorStop(1, c2);\r\n    return g;\r\n  };\r\n\r\n  // === 1. CAPE (Epic Flow) ===\r\n  // Outer layer (Dark Void)\r\n  const capeG = grad(0, -10, 0, 15, '#050508', '#000000');\r\n  ctx.fillStyle = capeG;\r\n  ctx.beginPath();\r\n  ctx.moveTo(-7, -4);\r\n  ctx.lineTo(-12, 12); // Wide flare\r\n  ctx.quadraticCurveTo(0, 15, 12, 12);\r\n  ctx.lineTo(7, -4);\r\n  ctx.fill();\r\n\r\n  // Volume folds (Subtle highlight)\r\n  ctx.fillStyle = 'rgba(20, 20, 30, 0.3)';\r\n  ctx.beginPath();\r\n  ctx.moveTo(-6, -4);\r\n  ctx.lineTo(-9, 11);\r\n  ctx.lineTo(-7, 12);\r\n  ctx.lineTo(-4, -4);\r\n  ctx.fill();\r\n  ctx.beginPath();\r\n  ctx.moveTo(6, -4);\r\n  ctx.lineTo(9, 11);\r\n  ctx.lineTo(7, 12);\r\n  ctx.lineTo(4, -4);\r\n  ctx.fill();\r\n\r\n  // === 2. LEGS (Cyber-Armor) ===\r\n  const drawLeg = (mx: number) => {\r\n    const side = mx < 0 ? -1 : 1;\r\n\r\n    // Thigh (Muscular Armor)\r\n    const thighG = grad(mx + side, 4, mx - side, 8, C_BASE_LIGHT, C_BASE_DARK);\r\n    ctx.fillStyle = thighG;\r\n    ctx.beginPath();\r\n    ctx.moveTo(mx + side, 4);\r\n    ctx.lineTo(mx + side * 0.5, 9);\r\n    ctx.lineTo(mx - side * 1.5, 8); // Inner knee\r\n    ctx.lineTo(mx, 4);\r\n    ctx.fill();\r\n\r\n    // Knee Plating (Diamond)\r\n    ctx.fillStyle = '#1a1a25';\r\n    ctx.beginPath();\r\n    ctx.moveTo(mx + side * 0.5, 7);\r\n    ctx.lineTo(mx + side * 2, 8);\r\n    ctx.lineTo(mx + side * 0.5, 10);\r\n    ctx.lineTo(mx - side, 8.5);\r\n    ctx.fill();\r\n    // Sharp Highlight\r\n    ctx.fillStyle = '#4a4a60';\r\n    ctx.beginPath();\r\n    ctx.moveTo(mx + side * 0.5, 7);\r\n    ctx.lineTo(mx + side * 1.5, 8);\r\n    ctx.lineTo(mx + side * 0.5, 8.5);\r\n    ctx.fill();\r\n\r\n    // Boot (Heavy & Sleek)\r\n    const bootG = grad(mx, 9, mx, 14, '#151520', '#020204');\r\n    ctx.fillStyle = bootG;\r\n    ctx.beginPath();\r\n    ctx.moveTo(mx - side * 1.5, 9);\r\n    ctx.lineTo(mx + side * 1.5, 9);\r\n    ctx.lineTo(mx + side * 2, 13);\r\n    ctx.lineTo(mx - side * 1, 14); // Heel\r\n    ctx.fill();\r\n\r\n    // Boot Tip (Grounded)\r\n    ctx.fillStyle = '#050508';\r\n    ctx.beginPath();\r\n    ctx.moveTo(mx + side * 2, 13);\r\n    ctx.lineTo(mx + side * 3.5, 14.5); // Pointier toe\r\n    ctx.lineTo(mx + side * 0.5, 15);\r\n    ctx.lineTo(mx - side, 14);\r\n    ctx.fill();\r\n\r\n    // Boot Rim Light\r\n    ctx.strokeStyle = C_RIM_LIGHT;\r\n    ctx.lineWidth = 0.5;\r\n    ctx.beginPath();\r\n    ctx.moveTo(mx + side * 1.5, 9);\r\n    ctx.lineTo(mx + side * 2, 13);\r\n    ctx.stroke();\r\n  };\r\n\r\n  drawLeg(-3.2);\r\n  drawLeg(3.2);\r\n\r\n  // === 3. TORSO (Anatomical Scuplture) ===\r\n\r\n  // Waist / Core\r\n  const waistG = grad(0, 4, 0, 7, C_BASE_MID, C_BASE_DARK);\r\n  ctx.fillStyle = waistG;\r\n  ctx.beginPath();\r\n  ctx.moveTo(-4, 4);\r\n  ctx.lineTo(4, 4);\r\n  ctx.lineTo(3, 7);\r\n  ctx.lineTo(-3, 7);\r\n  ctx.fill();\r\n\r\n  // Abdominal Plating (Ultra-defined)\r\n  ctx.fillStyle = '#050508'; // Dark gaps\r\n  ctx.globalAlpha = 0.6;\r\n  ctx.fillRect(-0.5, 1, 1, 6); // Center channel\r\n  ctx.fillRect(-3, 3, 6, 0.5); // Horiz line\r\n  ctx.fillRect(-2.5, 4.5, 5, 0.5); // Horiz line\r\n  ctx.globalAlpha = 1;\r\n\r\n  // Chest / Pecs (Power Armor)\r\n  const chestG = grad(0, -5, 0, 2, '#252535', '#101015');\r\n  ctx.fillStyle = chestG;\r\n  ctx.beginPath();\r\n  ctx.moveTo(-6, -5);\r\n  ctx.lineTo(6, -5);\r\n  ctx.lineTo(4, 4); // Taper to waist\r\n  ctx.lineTo(-4, 4);\r\n  ctx.fill();\r\n\r\n  // Pec Separation (Deep groove)\r\n  ctx.fillStyle = '#050508';\r\n  ctx.beginPath();\r\n  ctx.moveTo(0, -5);\r\n  ctx.lineTo(-0.5, 0); // Sternum\r\n  ctx.lineTo(0.5, 0);\r\n  ctx.lineTo(0, -5);\r\n  ctx.fill();\r\n\r\n  // Pec Rim Light (Definition)\r\n  ctx.strokeStyle = C_RIM_LIGHT;\r\n  ctx.lineWidth = 0.5;\r\n  ctx.beginPath();\r\n  ctx.moveTo(-6, -2); ctx.quadraticCurveTo(-3, -1, -0.5, 0);\r\n  ctx.moveTo(6, -2); ctx.quadraticCurveTo(3, -1, 0.5, 0);\r\n  ctx.stroke();\r\n\r\n  // === 4. ARMS & HANDS (Detailed) ===\r\n  const drawArm = (mx: number) => {\r\n    const side = mx < 0 ? -1 : 1;\r\n\r\n    // Shoulder (Pauldrons) - Multi-faceted\r\n    const shG = grad(mx, -6, mx, -1, C_BASE_LIGHT, C_BASE_DARK);\r\n    ctx.fillStyle = shG;\r\n    ctx.beginPath();\r\n    ctx.moveTo(mx, -5);\r\n    ctx.lineTo(mx + side * 4.5, -4.5);\r\n    ctx.lineTo(mx + side * 3.5, 1);\r\n    ctx.lineTo(mx + side, 0);\r\n    ctx.fill();\r\n    // Pauldron Rim\r\n    ctx.strokeStyle = C_RIM_LIGHT;\r\n    ctx.lineWidth = 0.5;\r\n    ctx.beginPath();\r\n    ctx.moveTo(mx, -5); ctx.lineTo(mx + side * 4.5, -4.5); ctx.lineTo(mx + side * 3.5, 1);\r\n    ctx.stroke();\r\n\r\n    // Arm (Bicep)\r\n    ctx.fillStyle = C_BASE_MID;\r\n    ctx.fillRect(mx + side * 1.5 - 1.5, 0, 3, 4.5);\r\n\r\n    // -- DETAILED HAND / GAUNTLET --\r\n    const hx = mx + side * 1.5;\r\n    const hy = 4.5;\r\n\r\n    // Gauntlet Bracer\r\n    ctx.fillStyle = '#1a1a25';\r\n    ctx.beginPath();\r\n    ctx.moveTo(hx - 2, hy);\r\n    ctx.lineTo(hx + 2, hy);\r\n    ctx.lineTo(hx + 2.5, hy + 3);\r\n    ctx.lineTo(hx - 2.5, hy + 3);\r\n    ctx.fill();\r\n\r\n    // Hand Base (Palm/Back)\r\n    ctx.fillStyle = '#0a0a10';\r\n    ctx.fillRect(hx - 2, hy + 3, 4, 3);\r\n\r\n    // Knuckles (Defined)\r\n    ctx.fillStyle = '#252535';\r\n    ctx.beginPath();\r\n    ctx.arc(hx - 1.5, hy + 6, 0.8, 0, Math.PI * 2); // Index\r\n    ctx.arc(hx + 0, hy + 6.2, 0.8, 0, Math.PI * 2); // Middle\r\n    ctx.arc(hx + 1.5, hy + 6, 0.8, 0, Math.PI * 2); // Ring\r\n    ctx.fill();\r\n\r\n    // Fingers (Closed Fist Grip)\r\n    ctx.fillStyle = '#151520';\r\n    ctx.beginPath();\r\n    ctx.moveTo(hx - 2, hy + 6);\r\n    ctx.lineTo(hx + 2, hy + 6);\r\n    ctx.lineTo(hx + 1.5, hy + 8.5); // Tapered finger tips\r\n    ctx.lineTo(hx - 1.5, hy + 8.5);\r\n    ctx.fill();\r\n\r\n    // Thumb (Wrapped)\r\n    ctx.fillStyle = '#202030';\r\n    ctx.beginPath();\r\n    ctx.moveTo(hx - side * 2, hy + 4);\r\n    ctx.lineTo(hx - side * 0.5, hy + 5);\r\n    ctx.lineTo(hx - side * 0.5, hy + 6.5);\r\n    ctx.lineTo(hx - side * 2.2, hy + 5.5);\r\n    ctx.fill();\r\n  };\r\n\r\n  drawArm(-5.5);\r\n  drawArm(5.5);\r\n\r\n  // === 5. SYMBOL (Celestial) ===\r\n  ctx.shadowColor = '#00ffff';\r\n  ctx.shadowBlur = 12;\r\n  ctx.fillStyle = '#ffffff';\r\n\r\n  // Moon\r\n  ctx.beginPath();\r\n  ctx.arc(0, -2, 2.2, 0, Math.PI * 2);\r\n  ctx.fill();\r\n\r\n  // Cutout\r\n  ctx.globalCompositeOperation = 'destination-out';\r\n  ctx.beginPath();\r\n  ctx.arc(0.7, -2.2, 1.8, 0, Math.PI * 2);\r\n  ctx.fill();\r\n  ctx.globalCompositeOperation = 'source-over';\r\n\r\n  // Star (Sharp)\r\n  ctx.fillStyle = '#ffffff';\r\n  ctx.beginPath();\r\n  const sx = 0.4, sy = -2.0;\r\n  const sSize = 0.6;\r\n  ctx.moveTo(sx, sy - sSize);\r\n  ctx.quadraticCurveTo(sx + sSize * 0.1, sy - sSize * 0.1, sx + sSize, sy);\r\n  ctx.quadraticCurveTo(sx + sSize * 0.1, sy + sSize * 0.1, sx, sy + sSize);\r\n  ctx.quadraticCurveTo(sx - sSize * 0.1, sy + sSize * 0.1, sx - sSize, sy);\r\n  ctx.quadraticCurveTo(sx - sSize * 0.1, sy - sSize * 0.1, sx, sy - sSize);\r\n  ctx.fill();\r\n  ctx.shadowBlur = 0;\r\n\r\n  // === 6. HEAD (The Nano Helmet) ===\r\n  const hy = -7;\r\n\r\n  // Helmet Gradient (Metallic sheen)\r\n  const headG = grad(0, hy - 8, 0, hy + 6, '#303045', '#020204');\r\n  ctx.fillStyle = headG;\r\n\r\n  // Silhouette Path\r\n  ctx.beginPath();\r\n  ctx.moveTo(0, hy + 5); // Chin\r\n  ctx.quadraticCurveTo(5, hy + 4, 6.5, hy - 1); // Cheek R (Wider)\r\n  ctx.lineTo(7.5, hy - 14); // Ear Tip R (Sharper)\r\n  ctx.lineTo(3, hy - 7);    // Top R\r\n  ctx.quadraticCurveTo(0, hy - 6, -3, hy - 7); // Top L\r\n  ctx.lineTo(-7.5, hy - 14); // Ear Tip L\r\n  ctx.lineTo(-6.5, hy - 1);  // Cheek L\r\n  ctx.quadraticCurveTo(-5, hy + 4, 0, hy + 5);  // Chin\r\n  ctx.fill();\r\n\r\n  // Helmet Inner Detail (Contrast)\r\n  ctx.fillStyle = '#000000';\r\n  ctx.beginPath();\r\n  ctx.moveTo(-5, hy - 4); ctx.lineTo(-6.5, hy - 11); ctx.lineTo(-3.5, hy - 6); ctx.fill();\r\n  ctx.beginPath();\r\n  ctx.moveTo(5, hy - 4); ctx.lineTo(6.5, hy - 11); ctx.lineTo(3.5, hy - 6); ctx.fill();\r\n\r\n  // Helmet Highlights (Glisten)\r\n  ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';\r\n  ctx.lineWidth = 0.8;\r\n  ctx.beginPath();\r\n  ctx.moveTo(-2, hy - 7); ctx.quadraticCurveTo(0, hy - 6, 2, hy - 7); // Forehead\r\n  ctx.stroke();\r\n\r\n  // Eyes (Piercing Soul)\r\n  ctx.shadowColor = '#00ffff';\r\n  ctx.shadowBlur = 18;\r\n  ctx.fillStyle = '#ffffff';\r\n\r\n  // Left Eye\r\n  ctx.beginPath();\r\n  ctx.ellipse(-2.8, hy, 2.2, 3.4, 0.35, 0, Math.PI * 2);\r\n  ctx.fill();\r\n  // Right Eye\r\n  ctx.beginPath();\r\n  ctx.ellipse(2.8, hy, 2.2, 3.4, -0.35, 0, Math.PI * 2);\r\n  ctx.fill();\r\n\r\n  ctx.shadowBlur = 0;\r\n\r\n  // Pupil/Depth Illusion\r\n  ctx.fillStyle = '#00ffff';\r\n  ctx.globalAlpha = 0.5;\r\n  ctx.beginPath();\r\n  ctx.ellipse(-2.8, hy, 1.4, 2.4, 0.35, 0, Math.PI * 2);\r\n  ctx.fill();\r\n  ctx.beginPath();\r\n  ctx.ellipse(2.8, hy, 1.4, 2.4, -0.35, 0, Math.PI * 2);\r\n  ctx.fill();\r\n  ctx.globalAlpha = 1;\r\n\r\n  // Final Rim Light (Backlighting - Crucial for \"Pop\")\r\n  ctx.strokeStyle = 'rgba(180, 230, 255, 0.4)';\r\n  ctx.lineWidth = 0.8;\r\n  ctx.beginPath();\r\n  ctx.moveTo(-6.5, hy - 1);\r\n  ctx.quadraticCurveTo(-5, hy - 8, -7.5, hy - 14); // Ear Rim L\r\n  ctx.stroke();\r\n\r\n  ctx.beginPath();\r\n  ctx.moveTo(6.5, hy - 1);\r\n  ctx.quadraticCurveTo(5, hy - 8, 7.5, hy - 14); // Ear Rim R\r\n  ctx.stroke();\r\n} */\r\n\r\n/**\r\n * Pose 0: Idle / Run (Sprite Integrated)\r\n */\r\nfunction drawIdleRunPose(ctx: CanvasRenderingContext2D, p: PlayerState, x: number, y: number, time: number) {\r\n  const isMoving = p.trail.length > 0 || p.isDashing;\r\n  const idleTime = p.idleTime || 0;\r\n\r\n  ctx.save();\r\n  ctx.translate(x, y);\r\n\r\n  // Character Body\r\n  drawOriginalCharacterBody(ctx, p, time);\r\n\r\n  // --- Weapon Attachment ---\r\n  if (idleTime <= 12) {\r\n    const isDual = p.weapon === 'daggers';\r\n    const side = p.facing.x >= 0 ? 1 : -1;\r\n    const pulse = 0.9 + Math.sin(time * 6) * 0.1;\r\n\r\n    // Resolve current frame\r\n    const frameOrFrames = getSpriteFrameForFacing(p);\r\n    const currentFrame = Array.isArray(frameOrFrames)\r\n      ? frameOrFrames[Math.floor(time * 10) % frameOrFrames.length]\r\n      : frameOrFrames;\r\n\r\n    // Determine active socket\r\n    const isFrontFrame = currentFrame.src.includes('frente') || currentFrame.src.includes('parado');\r\n    const isBackFrame = currentFrame.src.includes('costa');\r\n\r\n    // Determine active socket - Sprite flip already handles the side change\r\n    let socket = currentFrame.handSocket || (isBackFrame ? SOCKET_BACK_R : SOCKET_FRONT_R);\r\n\r\n\r\n    let sx = socket.x;\r\n    if (currentFrame.flipX) sx *= -1;\r\n    const sy = socket.y;\r\n\r\n    if (isDual) {\r\n      // DUAL WEAPONS (Dynamic symmetry)\r\n      const leftAngleBase = p.facing.x >= 0 ? Math.PI * 0.7 : Math.PI * 0.3;\r\n      const rightAngleBase = p.facing.x >= 0 ? Math.PI * 0.3 : Math.PI * 0.7;\r\n\r\n      // Estabiliza├º├úo Idle: balan├ºo reduzido quando parado\r\n      const runMag = isMoving ? 0.2 : 0.03;\r\n      const idleBackOff = (!isMoving && isBackFrame) ? -Math.PI * 0.1 : 0;\r\n\r\n      // Left\r\n      ctx.save();\r\n      const sxL = -sx;\r\n      drawEtherealHand(ctx, sxL, sy, pulse, time, 0, 0);\r\n      ctx.translate(sxL, sy);\r\n      ctx.rotate(leftAngleBase + idleBackOff + Math.sin(time * 3) * runMag);\r\n      drawEquippedWeapon(ctx, p, 32, 0, time, true);\r\n      ctx.restore();\r\n\r\n      // Right\r\n      ctx.save();\r\n      drawEtherealHand(ctx, sx, sy, pulse, time, 0, 0);\r\n      ctx.translate(sx, sy);\r\n      ctx.rotate(rightAngleBase + idleBackOff + Math.cos(time * 3) * runMag);\r\n      drawEquippedWeapon(ctx, p, 32, 0, time, true);\r\n      ctx.restore();\r\n    } else {\r\n      // SINGLE WEAPON - Use the frame-calculated socket and scale mirroring\r\n      const finalSx = sx;\r\n\r\n      let finalSy: number;\r\n      let rot: number;\r\n      let sway: number;\r\n\r\n      if (isMoving) {\r\n        // --- POSE DE CORRIDA (Anima├º├úo Original) ---\r\n        finalSy = sy; // Usa o socket original para bater com o movimento do sprite\r\n        sway = Math.sin(time * 10) * 0.08; // Balan├ºo de corrida mais forte\r\n\r\n        if (isFrontFrame) {\r\n          rot = Math.PI * 0.4; // Aponta para baixo/lado na corrida (Original)\r\n        } else if (isBackFrame) {\r\n          rot = -Math.PI * 0.3; // Aponta para cima/direita na corrida\r\n        } else {\r\n          rot = -Math.PI * 0.35;\r\n        }\r\n      } else {\r\n        // --- POSE PARADO (Calibrada para Encaixe Perfeito) ---\r\n        finalSy = -62; // Subido mais um pouco para tirar o cabo do p├® (pedido do user)\r\n        sway = Math.sin(time * 2) * 0.015; // Balan├ºo sutil de respira├º├úo\r\n\r\n        if (isFrontFrame) {\r\n          rot = -Math.PI * 0.55; // Aponta pra cima e para fora\r\n        } else if (isBackFrame) {\r\n          rot = -Math.PI * 0.25; // Aponta para cima/direita no idle\r\n        } else {\r\n          rot = -Math.PI * 0.6;\r\n        }\r\n      }\r\n\r\n      ctx.save();\r\n      ctx.translate(finalSx, finalSy);\r\n\r\n      if (p.weapon === 'staff') {\r\n        // STAFF POSITIONING: High presence, vertical, no flip scaling\r\n        drawVerticalStaff(ctx, 42, 0, time, p.facing.x);\r\n      } else {\r\n        if (p.facing.x < 0 && !isBackFrame) ctx.scale(-1, 1);\r\n        ctx.rotate(rot + sway);\r\n        // Corrected: p.weapon can only be 'sword' (or 'daggers' if logic allowed, but it's in the else of 'isDual')\r\n        const weaponLen = 34;\r\n        drawEquippedWeapon(ctx, p, weaponLen, isMoving ? 0.2 : 0, time);\r\n      }\r\n      ctx.restore();\r\n    }\r\n  }\r\n\r\n  ctx.restore();\r\n}\r\n\r\n/**\r\n * Pose 1: The Lunge (Forward Slash)\r\n * Body leans forward, Cloak drags back, Sword swings across.\r\n */\r\nfunction drawAttackPose1(ctx: CanvasRenderingContext2D, p: PlayerState, x: number, y: number, time: number, t: number) {\r\n  const isKatana = p.weapon === 'daggers';\r\n  const facing = p.facing.x;\r\n\r\n  // Lunge: Small advance\r\n  const lunge = isKatana ? 8 * (t < 0.2 ? 0 : (t - 0.2) / 0.8) : 0;\r\n  const bx = x + Math.cos(p.meleeAngle) * lunge;\r\n  const by = y + Math.sin(p.meleeAngle) * lunge;\r\n\r\n  ctx.save();\r\n  ctx.translate(bx, by);\r\n  drawOriginalCharacterBody(ctx, p, time);\r\n  ctx.restore();\r\n\r\n  // Attack 1: Swift Horizontal (R -> L)\r\n  const angleStart = p.meleeAngle - C.MELEE_ARC / 2;\r\n  const angleEnd = p.meleeAngle + C.MELEE_ARC / 2;\r\n\r\n  let swingT = t < 0.1 ? 0 : Math.min(1, (t - 0.1) / 0.5);\r\n  swingT = 1 - Math.pow(1 - swingT, 4);\r\n  const currentAngle = angleStart + (angleEnd - angleStart) * swingT;\r\n\r\n  const frameOrFrames = getSpriteFrameForFacing(p);\r\n  const currentFrame = Array.isArray(frameOrFrames) ? frameOrFrames[0] : frameOrFrames;\r\n  const isFront = currentFrame.src.includes('parado') || currentFrame.src.includes('frente');\r\n  const socketR = isFront ? SOCKET_FRONT_R : (currentFrame.handSocket || SOCKET_FRONT_R);\r\n  const sx = socketR.x * (currentFrame.flipX ? -1 : 1);\r\n\r\n  ctx.save();\r\n  ctx.translate(bx + sx, y + socketR.y);\r\n  ctx.rotate(currentAngle);\r\n  drawEquippedWeapon(ctx, p, 38, 1, time, true);\r\n  ctx.restore();\r\n\r\n  if (t > 0.1 && t < 0.6) {\r\n    drawSlashTrail(ctx, bx, by, C.MELEE_RANGE * 0.85, angleStart, currentAngle, 'azure');\r\n  }\r\n}\r\n\r\n/**\r\n * Pose 2: The Twist (Backhand)\r\n * Body twists back, Sword swings Left -> Right (Reverse).\r\n */\r\nfunction drawAttackPose2(ctx: CanvasRenderingContext2D, p: PlayerState, x: number, y: number, time: number, t: number) {\r\n  const isKatana = p.weapon === 'daggers';\r\n  const facing = p.facing.x;\r\n\r\n  // Attack 2: Inverted Horizontal - 360 Lunge\r\n  const lunge = isKatana ? 12 * (t < 0.1 ? 0 : (t - 0.1) / 0.9) : 0;\r\n  const bx = x + Math.cos(p.meleeAngle) * lunge;\r\n  const by = y + Math.sin(p.meleeAngle) * lunge;\r\n\r\n  ctx.save();\r\n  ctx.translate(bx, by);\r\n  drawOriginalCharacterBody(ctx, p, time);\r\n  ctx.restore();\r\n\r\n  const angleStart = p.meleeAngle + C.MELEE_ARC / 2;\r\n  const angleEnd = p.meleeAngle - C.MELEE_ARC / 2;\r\n\r\n  let swingT = t < 0.05 ? 0 : Math.min(1, (t - 0.05) / 0.4);\r\n  swingT = 1 - Math.pow(1 - swingT, 5);\r\n  const currentAngle = angleStart + (angleEnd - angleStart) * swingT;\r\n\r\n  const frameOrFrames = getSpriteFrameForFacing(p);\r\n  const currentFrame = Array.isArray(frameOrFrames) ? frameOrFrames[0] : frameOrFrames;\r\n  const isFront = currentFrame.src.includes('parado') || currentFrame.src.includes('frente');\r\n  const socketR = isFront ? SOCKET_FRONT_R : (currentFrame.handSocket || SOCKET_FRONT_R);\r\n  const sx = socketR.x * (currentFrame.flipX ? -1 : 1);\r\n\r\n  ctx.save();\r\n  ctx.translate(bx + sx, y + socketR.y);\r\n  ctx.rotate(currentAngle);\r\n  ctx.scale(1, -1); // Visual trick for reverse cut\r\n  drawEquippedWeapon(ctx, p, 38, 1, time, true);\r\n  ctx.restore();\r\n\r\n  if (t > 0.05 && t < 0.5) {\r\n    drawSlashTrail(ctx, bx, by, C.MELEE_RANGE * 0.85, angleStart, currentAngle, 'azure');\r\n  }\r\n}\r\n\r\n/**\r\n * Pose 3: The Heavy Smash\r\n * Jump up -> Slam down. Sword Overhead.\r\n */\r\nfunction drawAttackPose3(ctx: CanvasRenderingContext2D, p: PlayerState, x: number, y: number, time: number, t: number) {\r\n  const isKatana = p.weapon === 'daggers';\r\n  const facing = p.facing.x;\r\n\r\n  // LIFT: Body moves slightly up during diagonal upslash + small lunge\r\n  const liftY = isKatana ? Math.sin(t * Math.PI) * -6 : 0;\r\n  const lunge = isKatana ? 5 : 0;\r\n  const bx = x + Math.cos(p.meleeAngle) * lunge;\r\n  const by = y + Math.sin(p.meleeAngle) * lunge;\r\n\r\n  ctx.save();\r\n  ctx.translate(bx, by + liftY);\r\n  drawOriginalCharacterBody(ctx, p, time);\r\n  ctx.restore();\r\n\r\n  // Weapon: Diagonal Upward Slash\r\n  const angleStart = p.meleeAngle + Math.PI * 0.4;\r\n  const angleEnd = p.meleeAngle - Math.PI * 0.4;\r\n\r\n  let swingT = t < 0.1 ? 0 : Math.min(1, (t - 0.1) / 0.4);\r\n  swingT = Math.pow(swingT, 2);\r\n  const currentAngle = angleStart + (angleEnd - angleStart) * swingT;\r\n\r\n  const frameOrFrames = getSpriteFrameForFacing(p);\r\n  const currentFrame = Array.isArray(frameOrFrames) ? frameOrFrames[0] : frameOrFrames;\r\n  const isFront = currentFrame.src.includes('parado') || currentFrame.src.includes('frente');\r\n  const socketR = isFront ? SOCKET_FRONT_R : (currentFrame.handSocket || SOCKET_FRONT_R);\r\n  const sx = socketR.x * (currentFrame.flipX ? -1 : 1);\r\n\r\n  ctx.save();\r\n  ctx.translate(bx + sx, y + liftY + socketR.y);\r\n  ctx.rotate(currentAngle);\r\n  drawEquippedWeapon(ctx, p, 42, 1, time, true);\r\n  ctx.restore();\r\n\r\n  if (t > 0.1 && t < 0.6) {\r\n    drawSlashTrail(ctx, bx, by + liftY, C.MELEE_RANGE * 1.0, angleStart, currentAngle, 'iron');\r\n  }\r\n}\r\n\r\n/**\r\n * Pose 4: The Vortex (Finisher)\r\n * 360 Spin.\r\n */\r\nfunction drawAttackPose4(ctx: CanvasRenderingContext2D, p: PlayerState, x: number, y: number, time: number, t: number) {\r\n  const isKatana = p.weapon === 'daggers';\r\n  const facing = p.facing.x;\r\n\r\n  // IAIJUTSU DASH: High speed advance in 360 degrees\r\n  const dashDist = isKatana ? 45 * Math.min(1, t / 0.4) : 0;\r\n  const bx = x + Math.cos(p.meleeAngle) * dashDist;\r\n  const by = y + Math.sin(p.meleeAngle) * dashDist;\r\n\r\n  ctx.save();\r\n  ctx.translate(bx, by);\r\n  drawOriginalCharacterBody(ctx, p, time);\r\n  ctx.restore();\r\n\r\n  // DOUBLE CROSS SLASH (X)\r\n  const angleStart = p.meleeAngle - C.MELEE_ARC / 1.2;\r\n  const angleEnd = p.meleeAngle + C.MELEE_ARC / 1.2;\r\n\r\n  let swingT = t < 0.3 ? 0 : Math.min(1, (t - 0.3) / 0.5);\r\n  swingT = 1 - Math.pow(1 - swingT, 4);\r\n  const currentAngle = angleStart + (angleEnd - angleStart) * swingT;\r\n\r\n  const frameOrFrames = getSpriteFrameForFacing(p);\r\n  const currentFrame = Array.isArray(frameOrFrames) ? frameOrFrames[0] : frameOrFrames;\r\n  const isFront = currentFrame.src.includes('parado') || currentFrame.src.includes('frente');\r\n  const socketR = isFront ? SOCKET_FRONT_R : (currentFrame.handSocket || SOCKET_FRONT_R);\r\n  const socketL = isFront ? SOCKET_FRONT_L : { x: -socketR.x, y: socketR.y };\r\n\r\n  const sxR = socketR.x * (currentFrame.flipX ? -1 : 1);\r\n  const sxL = socketL.x * (currentFrame.flipX ? -1 : 1);\r\n\r\n  // Draw two katanas in an X pattern\r\n  ctx.save();\r\n  ctx.translate(bx + sxR, y + socketR.y);\r\n  ctx.rotate(currentAngle);\r\n  drawEquippedWeapon(ctx, p, 44, 1, time, true);\r\n  ctx.restore();\r\n\r\n  const angleStartL = p.meleeAngle + C.MELEE_ARC / 1.2;\r\n  const angleEndL = p.meleeAngle - C.MELEE_ARC / 1.2;\r\n  const currentAngleL = angleStartL + (angleEndL - angleStartL) * swingT;\r\n\r\n  ctx.save();\r\n  ctx.translate(bx + sxL, y + socketL.y);\r\n  ctx.rotate(currentAngleL);\r\n  drawEquippedWeapon(ctx, p, 44, 1, time, true);\r\n  ctx.restore();\r\n\r\n  if (t > 0.3 && t < 0.8) {\r\n    drawSlashTrail(ctx, bx, by, C.MELEE_RANGE * 1.4, angleStart, currentAngle, 'azure');\r\n    drawSlashTrail(ctx, bx, by, C.MELEE_RANGE * 1.4, angleStartL, currentAngleL, 'azure');\r\n  }\r\n}\r\n\r\nfunction drawSlashTrail(ctx: CanvasRenderingContext2D, x: number, y: number, r: number, start: number, end: number, color: 'azure' | 'gold' | 'crimson' | 'iron') {\r\n  ctx.save();\r\n\r\n  let mainColor = 'rgba(100, 200, 255, 0.12)'; // Default azure\r\n  let sharpColor = 'rgba(255, 255, 255, 0.8)';\r\n  let glowColor = 'rgba(100, 200, 255, 0)';\r\n\r\n  if (color === 'gold') {\r\n    mainColor = 'rgba(255, 200, 0, 0.12)';\r\n    sharpColor = 'rgba(255, 255, 200, 0.8)';\r\n    glowColor = 'rgba(255, 200, 0, 0)';\r\n  } else if (color === 'crimson') {\r\n    mainColor = 'rgba(255, 50, 50, 0.12)';\r\n    sharpColor = 'rgba(255, 200, 200, 0.8)';\r\n    glowColor = 'rgba(255, 50, 50, 0)';\r\n  }\r\n\r\n  // Layer 1: Focused Blade Edge (The sharp part)\r\n  const bladeGrad = ctx.createRadialGradient(x, y, r * 0.95, x, y, r);\r\n  bladeGrad.addColorStop(0, color === 'iron' ? 'rgba(150, 150, 160, 0)' : 'rgba(200, 240, 255, 0)');\r\n  bladeGrad.addColorStop(0.5, sharpColor); // Sharp white core\r\n  bladeGrad.addColorStop(1, glowColor);\r\n\r\n  ctx.fillStyle = bladeGrad;\r\n  ctx.beginPath();\r\n  ctx.moveTo(x, y);\r\n  ctx.arc(x, y, r, start, end, start > end);\r\n  ctx.fill();\r\n\r\n  // Layer 2: Ethereal Energy Tail (Subtle dissipation)\r\n  const auraGrad = ctx.createRadialGradient(x, y, r * 0.7, x, y, r * 1.05);\r\n  auraGrad.addColorStop(0, 'rgba(100, 180, 255, 0)');\r\n  auraGrad.addColorStop(0.5, mainColor);\r\n  auraGrad.addColorStop(1, 'rgba(100, 180, 255, 0)');\r\n\r\n  ctx.fillStyle = auraGrad;\r\n  ctx.beginPath();\r\n  ctx.moveTo(x, y);\r\n  ctx.arc(x, y, r * 1.05, start, end, start > end);\r\n  ctx.fill();\r\n  ctx.restore();\r\n}\r\n\r\n/** Draws a sharp white glint/spark at contact point */\r\nfunction drawImpactGlint(ctx: CanvasRenderingContext2D, x: number, y: number, alpha: number, size = 12) {\r\n  ctx.save();\r\n  ctx.globalCompositeOperation = 'lighter';\r\n  ctx.globalAlpha = alpha;\r\n\r\n  const g = ctx.createRadialGradient(x, y, 0, x, y, size);\r\n  g.addColorStop(0, 'rgba(255, 255, 255, 1)');\r\n  g.addColorStop(0.4, 'rgba(255, 255, 255, 0.4)');\r\n  g.addColorStop(1, 'rgba(255, 255, 255, 0)');\r\n\r\n  ctx.fillStyle = g;\r\n  ctx.beginPath();\r\n  ctx.arc(x, y, size, 0, Math.PI * 2);\r\n  ctx.fill();\r\n\r\n  // Horizontal/Vertical sharp crosses\r\n  ctx.strokeStyle = 'white';\r\n  ctx.lineWidth = 1;\r\n  ctx.beginPath();\r\n  ctx.moveTo(x - size, y); ctx.lineTo(x + size, y);\r\n  ctx.moveTo(x, y - size); ctx.lineTo(x, y + size);\r\n  ctx.stroke();\r\n\r\n  ctx.restore();\r\n}\r\n\r\n\r\n\r\n/** Draws a mystical ethereal hand */\r\nfunction drawEtherealHand(ctx: CanvasRenderingContext2D, handX: number, handY: number, scale: number, time: number, coreX: number, coreY: number) {\r\n  ctx.save();\r\n  ctx.translate(handX, handY);\r\n\r\n  // Energy connection thread back to the character core\r\n  ctx.strokeStyle = 'rgba(150, 230, 255, 0.2)';\r\n  ctx.setLineDash([2, 2]); // Dotted energy feel\r\n  ctx.lineWidth = 0.5;\r\n  ctx.beginPath();\r\n  // Relative coordinates back to core\r\n  ctx.moveTo(coreX - handX, coreY - handY);\r\n  ctx.lineTo(0, 0); // Hand center\r\n  ctx.stroke();\r\n  ctx.setLineDash([]); // Reset\r\n\r\n  // Outer soft glow\r\n  const g = ctx.createRadialGradient(0, 0, 0, 0, 0, 8 * scale);\r\n  g.addColorStop(0, 'rgba(100, 200, 255, 0.4)');\r\n  g.addColorStop(0.5, 'rgba(50, 150, 255, 0.2)');\r\n  g.addColorStop(1, 'rgba(0, 100, 255, 0)');\r\n  ctx.fillStyle = g;\r\n  ctx.beginPath();\r\n  ctx.arc(0, 0, 8 * scale, 0, Math.PI * 2);\r\n  ctx.fill();\r\n\r\n  // \"Finger\" particles (procedural energy wisps)\r\n  ctx.fillStyle = 'rgba(150, 230, 255, 0.6)';\r\n  for (let i = 0; i < 3; i++) {\r\n    const angle = (time * 5) + (i * Math.PI * 2 / 3);\r\n    const rx = Math.cos(angle) * 3 * scale;\r\n    const ry = Math.sin(angle) * 3 * scale;\r\n    ctx.beginPath();\r\n    ctx.arc(rx, ry, 1.5 * scale, 0, Math.PI * 2);\r\n    ctx.fill();\r\n  }\r\n\r\n  // Core\r\n  ctx.fillStyle = '#ffffff';\r\n  ctx.beginPath();\r\n  ctx.arc(0, 0, 2 * scale, 0, Math.PI * 2);\r\n  ctx.fill();\r\n\r\n  ctx.restore();\r\n}\r\n\r\n/** Draws the equipped weapon based on player choice.\r\n *  @param singleOnly If true, only draws one instance (useful for dual-wielding hand-by-hand)\r\n */\r\nfunction drawEquippedWeapon(ctx: CanvasRenderingContext2D, p: PlayerState, length: number, isAttacking: number, time: number, singleOnly = false) {\r\n  switch (p.weapon) {\r\n    case 'daggers': drawDualDaggers(ctx, length, isAttacking, time, singleOnly); break;\r\n    case 'staff': drawVoidStaff(ctx, length, isAttacking, time); break;\r\n    default: drawLongsword(ctx, length, isAttacking, time); break;\r\n  }\r\n}\r\n\r\n\r\n/** Draws professional Dual Katanas with independent hand support */\r\nfunction drawDualDaggers(ctx: CanvasRenderingContext2D, length: number, isAttacking: number, time: number, singleOnly = false) {\r\n  const katLen = length * 1.1; // Aumentado fator de escala\r\n  const hiltLen = 12; // Cabo maior e mais vis├¡vel\r\n  const bladeLen = katLen - hiltLen;\r\n  const tsubaRadius = 5; // Guarda (tsuba) mais imponente\r\n  const bladeWidth = 2.5; // L├ómina mais larga e \"AAA\"\r\n\r\n  const drawOne = (extraRot: number) => {\r\n    // Piv├┤ Estrutural: Centro do Cabo (Hilt ├® 8px total)\r\n    // Piv├┤ em 0 significa que o cabo vai de -4 a +4\r\n    ctx.save();\r\n    ctx.rotate(extraRot);\r\n\r\n    // 1. Tsuka (Hilt) - Cabo centrado\r\n    // 1. Tsuka (Hilt) - Cabo centrado (Cores Matte e Bronze)\r\n    ctx.fillStyle = '#050505';\r\n    ctx.fillRect(-hiltLen / 2, -1.2, hiltLen, 2.4);\r\n\r\n    // Tsuka-ito (Diamonds)\r\n    ctx.fillStyle = '#222';\r\n    for (let i = 0; i < 3; i++) {\r\n      ctx.beginPath();\r\n      ctx.arc(-hiltLen / 2 + 3 + i * 3, 0, 0.8, 0, Math.PI * 2);\r\n      ctx.fill();\r\n    }\r\n\r\n    // 2. Tsuba (Circular guard) - Na jun├º├úo\r\n    const tG = ctx.createRadialGradient(hiltLen / 2, 0, 0, hiltLen / 2, 0, tsubaRadius);\r\n    tG.addColorStop(0, '#886622'); // Bronze/Gold\r\n    tG.addColorStop(1, '#221100');\r\n    ctx.fillStyle = tG;\r\n    ctx.beginPath();\r\n    ctx.arc(hiltLen / 2, 0, tsubaRadius, 0, Math.PI * 2);\r\n    ctx.fill();\r\n\r\n    // 3. Curved Blade - High Contrast AAA\r\n    const bGrad = ctx.createLinearGradient(hiltLen / 2, -bladeWidth, hiltLen / 2, bladeWidth);\r\n    bGrad.addColorStop(0, '#0a0a0a');\r\n    bGrad.addColorStop(0.3, '#ffffff'); // Hamon line feel\r\n    bGrad.addColorStop(0.5, '#cccccc');\r\n    bGrad.addColorStop(1, '#111111');\r\n    ctx.fillStyle = bGrad;\r\n\r\n    const curve = isAttacking ? 5 : 3;\r\n    ctx.beginPath();\r\n    ctx.moveTo(hiltLen / 2, -bladeWidth / 2);\r\n    ctx.quadraticCurveTo(hiltLen / 2 + bladeLen * 0.5, -bladeWidth / 2 - curve, hiltLen / 2 + bladeLen, -curve);\r\n    ctx.lineTo(hiltLen / 2 + bladeLen, -curve + 1.2);\r\n    ctx.quadraticCurveTo(hiltLen / 2 + bladeLen * 0.5, bladeWidth / 2 - curve + 1.2, hiltLen / 2, bladeWidth / 2);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n\r\n    // Blade Edge Shimmer\r\n    if (isAttacking) {\r\n      ctx.strokeStyle = 'rgba(200, 255, 255, 0.4)';\r\n      ctx.lineWidth = 0.5;\r\n      ctx.beginPath();\r\n      ctx.moveTo(hiltLen / 2, -bladeWidth / 4);\r\n      ctx.quadraticCurveTo(hiltLen / 2 + bladeLen * 0.5, -bladeWidth / 4 - curve, hiltLen / 2 + bladeLen, -curve);\r\n      ctx.stroke();\r\n    }\r\n\r\n    ctx.restore();\r\n  };\r\n\r\n  if (singleOnly) {\r\n    drawOne(0);\r\n  } else {\r\n    // Modo dual (apenas para fallback se n├úo usar sockets)\r\n    ctx.save();\r\n    ctx.translate(0, -8);\r\n    drawOne(Math.sin(time * 3) * 0.1);\r\n    ctx.restore();\r\n\r\n    ctx.save();\r\n    ctx.translate(0, 8);\r\n    drawOne(Math.cos(time * 3) * 0.1);\r\n    ctx.restore();\r\n  }\r\n}\r\n\r\n\r\n/** Draws a professional-grade AAA longsword */\r\nfunction drawLongsword(ctx: CanvasRenderingContext2D, length: number, isAttacking: number, time: number) {\r\n  // Increase proportions for a larger, more impactful weapon\r\n  // Piv├┤ Estrutural: Centro do Cabo (Handle)\r\n  // O cabo tem 10px de comprimento. Centro em x=0 -> Cabo de -5 a +5.\r\n  const hiltLen = 10;\r\n  const guardW = 16;\r\n  const bladeLen = length - hiltLen;\r\n\r\n  // 1. Hilt (Leather wrapped)\r\n  ctx.fillStyle = '#1a0f08';\r\n  ctx.fillRect(-hiltLen / 2, -2, hiltLen, 4);\r\n\r\n  // Leather wraps detail - Ajustadas para o novo centro\r\n  ctx.strokeStyle = '#3d2b1f';\r\n  ctx.lineWidth = 0.8;\r\n  for (let i = 0; i < 5; i++) {\r\n    const ox = -hiltLen / 2 + 1 + i * 1.8;\r\n    ctx.beginPath();\r\n    ctx.moveTo(ox, -2);\r\n    ctx.lineTo(ox + 0.8, 2);\r\n    ctx.stroke();\r\n  }\r\n\r\n  // 2. Heavy Weighted Pommel - No in├¡cio do cabo\r\n  const pommelGrad = ctx.createRadialGradient(-hiltLen / 2, 0, 0, -hiltLen / 2, 0, 3.5);\r\n  pommelGrad.addColorStop(0, '#ffcc33');\r\n  pommelGrad.addColorStop(1, '#aa8833');\r\n  ctx.fillStyle = pommelGrad;\r\n  ctx.beginPath();\r\n  ctx.arc(-hiltLen / 2, 0, 3.5, 0, Math.PI * 2);\r\n  ctx.fill();\r\n\r\n  // 3. Ornate Crossguard - Na jun├º├úo com a l├ómina (x = hiltLen/2)\r\n  const silverGrad = ctx.createLinearGradient(hiltLen / 2, -guardW / 2, hiltLen / 2, guardW / 2);\r\n  silverGrad.addColorStop(0, '#555555');\r\n  silverGrad.addColorStop(0.2, '#aaaaaa');\r\n  silverGrad.addColorStop(0.5, '#ffffff');\r\n  silverGrad.addColorStop(1, '#444444');\r\n  ctx.fillStyle = silverGrad;\r\n\r\n  ctx.beginPath();\r\n  ctx.moveTo(hiltLen / 2, -guardW / 2);\r\n  ctx.bezierCurveTo(hiltLen / 2 - 4, -guardW / 4, hiltLen / 2 - 4, guardW / 4, hiltLen / 2, guardW / 2);\r\n  ctx.lineTo(hiltLen / 2 + 3, guardW / 3);\r\n  ctx.lineTo(hiltLen / 2 + 3, -guardW / 3);\r\n  ctx.closePath();\r\n  ctx.fill();\r\n\r\n  // 4. Central Magical Gem - No centro da guarda\r\n  const gemPulse = 0.8 + Math.sin(time * 5) * 0.2;\r\n  const gemGrad = ctx.createRadialGradient(hiltLen / 2, 0, 0, hiltLen / 2, 0, 2.5);\r\n  gemGrad.addColorStop(0, '#ffffff');\r\n  gemGrad.addColorStop(1, '#0044ff');\r\n  ctx.fillStyle = gemGrad;\r\n  ctx.beginPath();\r\n  ctx.arc(hiltLen / 2, 0, 2 * gemPulse, 0, Math.PI * 2);\r\n  ctx.fill();\r\n\r\n  // 5. Elite Blade - Come├ºando ap├│s a guarda\r\n  const bladeWidth = 3.2;\r\n  const bladeGrad = ctx.createLinearGradient(hiltLen / 2 + 3, -bladeWidth, hiltLen / 2 + 3, bladeWidth);\r\n  bladeGrad.addColorStop(0, '#444444');\r\n  bladeGrad.addColorStop(0.5, '#e0f0ff');\r\n  bladeGrad.addColorStop(1, '#333333');\r\n\r\n  ctx.fillStyle = bladeGrad;\r\n  ctx.beginPath();\r\n  ctx.moveTo(hiltLen / 2 + 3, -bladeWidth);\r\n  ctx.lineTo(hiltLen / 2 + bladeLen - 5, -bladeWidth * 0.7);\r\n  ctx.lineTo(hiltLen / 2 + bladeLen, 0);\r\n  ctx.lineTo(hiltLen / 2 + bladeLen - 5, bladeWidth * 0.7);\r\n  ctx.lineTo(hiltLen / 2 + 3, bladeWidth);\r\n  ctx.closePath();\r\n  ctx.fill();\r\n\r\n  // 6. Deep Fuller (Central Groove)\r\n  ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';\r\n  ctx.fillRect(8, -0.8, bladeLen - 20, 1.6);\r\n\r\n  // 7. Dynamic Blade Shimmer (Glint)\r\n  const shineSpeed = isAttacking ? 20 : 4;\r\n  const shinePos = (Math.sin(time * shineSpeed) * 0.5 + 0.5) * (bladeLen - 10) + 10;\r\n  const g = ctx.createRadialGradient(shinePos, 0, 0, shinePos, 0, 6);\r\n  g.addColorStop(0, 'rgba(135, 206, 250, 0.5)');\r\n  g.addColorStop(1, 'rgba(100, 200, 255, 0)');\r\n\r\n  ctx.save();\r\n  ctx.globalCompositeOperation = 'screen';\r\n  ctx.fillStyle = g;\r\n  ctx.beginPath();\r\n  ctx.arc(shinePos, 0, 3, 0, Math.PI * 2);\r\n  ctx.fill();\r\n  ctx.restore();\r\n}\r\n\r\n\r\n\r\n\r\n/** Draws a professional-grade AAA Void Staff */\r\nfunction drawVoidStaff(ctx: CanvasRenderingContext2D, length: number, isAttacking: number, time: number) {\r\n  const staffLen = length * 1.35;\r\n  const shaftWidth = 3.5;\r\n\r\n  // 1. Dark Ebonwood Shaft\r\n  const shaftGrad = ctx.createLinearGradient(-staffLen + 10, 0, 0, 0);\r\n  shaftGrad.addColorStop(0, '#020204'); // Deep midnight\r\n  shaftGrad.addColorStop(0.4, '#0a0815'); // Dark violet wood\r\n  shaftGrad.addColorStop(0.6, '#080510');\r\n  shaftGrad.addColorStop(1, '#020204');\r\n\r\n  ctx.fillStyle = shaftGrad;\r\n  ctx.beginPath();\r\n  // Tapered design\r\n  ctx.moveTo(-staffLen + 10, -shaftWidth * 0.4);\r\n  ctx.lineTo(0, -shaftWidth * 0.5);\r\n  ctx.lineTo(2, 0); // Point\r\n  ctx.lineTo(0, shaftWidth * 0.5);\r\n  ctx.lineTo(-staffLen + 10, shaftWidth * 0.4);\r\n  ctx.closePath();\r\n  ctx.fill();\r\n\r\n  // Ornate bindings\r\n  ctx.fillStyle = '#2a283a';\r\n  for (let i = 0; i < 3; i++) {\r\n    ctx.fillRect(-staffLen + 15 + i * (staffLen / 4), -shaftWidth * 0.6, 2, shaftWidth * 1.2);\r\n  }\r\n\r\n  // 2. The Void Head (Crescent structure)\r\n  ctx.save();\r\n  ctx.translate(14, 0);\r\n\r\n  // Dark metallic structure\r\n  ctx.fillStyle = '#0a0a0f';\r\n  ctx.beginPath();\r\n  ctx.arc(0, 0, 10, -Math.PI * 0.7, Math.PI * 0.7);\r\n  ctx.lineTo(0, 0);\r\n  ctx.closePath();\r\n  ctx.fill();\r\n\r\n  // 3. Floating Ethereal Core\r\n  const corePulse = 0.95 + Math.sin(time * 4) * 0.05;\r\n  const coreSize = 7 * corePulse;\r\n\r\n  // Outer Glow\r\n  const glowG = ctx.createRadialGradient(0, 0, 0, 0, 0, 15);\r\n  glowG.addColorStop(0, 'rgba(160, 50, 255, 0.3)');\r\n  glowG.addColorStop(1, 'rgba(80, 0, 120, 0)');\r\n  ctx.fillStyle = glowG;\r\n  ctx.beginPath();\r\n  ctx.arc(0, 0, 15, 0, Math.PI * 2);\r\n  ctx.fill();\r\n\r\n  // The Core\r\n  const orbGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, coreSize);\r\n  orbGrad.addColorStop(0, '#ffffff'); // Heart\r\n  orbGrad.addColorStop(0.2, '#aa66ff'); // Inner violet\r\n  orbGrad.addColorStop(0.6, '#4b0082'); // Deep indigo\r\n  orbGrad.addColorStop(1, '#050010');\r\n  ctx.fillStyle = orbGrad;\r\n  ctx.beginPath();\r\n  ctx.arc(0, 0, coreSize, 0, Math.PI * 2);\r\n  ctx.fill();\r\n\r\n  // 4. Orbiting Shards\r\n  for (let i = 0; i < 3; i++) {\r\n    const orbitAngle = time * 2.5 + (i * Math.PI * 2 / 3);\r\n    const orbitDist = 12 + Math.sin(time * 3 + i) * 2;\r\n    const ox = Math.cos(orbitAngle) * orbitDist;\r\n    const oy = Math.sin(orbitAngle) * orbitDist * 0.5;\r\n\r\n    ctx.fillStyle = '#110022';\r\n    ctx.save();\r\n    ctx.translate(ox, oy);\r\n    ctx.rotate(orbitAngle * 2);\r\n    ctx.beginPath();\r\n    ctx.moveTo(0, -2); ctx.lineTo(1.5, 0); ctx.lineTo(0, 2); ctx.lineTo(-1.5, 0);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n    ctx.restore();\r\n  }\r\n\r\n  ctx.restore();\r\n}\r\n\r\n/** Draws the staff in its \"Vertical\" state for the player */\r\nfunction drawVerticalStaff(ctx: CanvasRenderingContext2D, length: number, isAttacking: number, time: number, facingX: number) {\r\n  ctx.save();\r\n  // Fixed vertical rotation: always straight up with a tiny rhythmic sway\r\n  const sway = Math.sin(time * 2.5) * 0.03;\r\n  ctx.rotate(-Math.PI / 2 + sway);\r\n\r\n  // Pivot Adjustment: Hand grasps about 1/3 up from the bottom\r\n  // Move the staff UP so the head is higher and the tail also sits above the floor\r\n  ctx.translate(28, 0);\r\n\r\n  drawVoidStaff(ctx, length, isAttacking, time);\r\n  ctx.restore();\r\n}\r\n\r\n\r\n/** ÔòÉÔòÉÔòÉ WEAPON SELECTION OVERLAY ÔòÉÔòÉÔòÉ */\r\nexport function renderWeaponSelectionOverlay(ctx: CanvasRenderingContext2D, selectedIndex: number, options: { id: WeaponType; name: string; desc: string; locked?: boolean }[], time: number, vp: Viewport) {\r\n  const { rw, rh } = vp;\r\n  const cx = rw / 2;\r\n  const cy = rh / 2;\r\n  const isMobileScreen = rw < 500 || rh < 380;\r\n  ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';\r\n  ctx.fillRect(0, 0, rw, rh);\r\n  ctx.textAlign = 'center';\r\n  ctx.fillStyle = '#ffffff';\r\n  const titleSize = isMobileScreen ? 18 : 24;\r\n  ctx.font = `bold ${titleSize}px ${C.HUD_FONT}`;\r\n  ctx.fillText('ESCOLHA SUA ARMA', cx, rh * 0.2);\r\n  ctx.font = `${isMobileScreen ? 10 : 12}px ${C.HUD_FONT}`;\r\n  ctx.fillStyle = 'rgba(200, 200, 200, 0.7)';\r\n  if (isMobileScreen) {\r\n    ctx.fillText('TOQUE na carta para selecionar', cx, rh * 0.28);\r\n  } else {\r\n    ctx.fillText('Aperte [A / D] para navegar  ÔÇó  [ENTER] para confirmar  ÔÇó  ou clique na carta', cx, rh * 0.25);\r\n  }\r\n\r\n  const cardW = isMobileScreen ? 78 : 90;\r\n  const cardH = isMobileScreen ? 118 : 140;\r\n  const spacing = isMobileScreen ? 12 : 20;\r\n  const startX = cx - (options.length * (cardW + spacing) - spacing) / 2 + cardW / 2;\r\n\r\n  options.forEach((opt, i) => {\r\n    const isSelected = i === selectedIndex;\r\n    const isLocked = opt.locked;\r\n    const x = startX + i * (cardW + spacing);\r\n    const y = cy + (isMobileScreen ? 12 : 0);\r\n    const hover = (isSelected && !isLocked) ? Math.sin(time * 4) * 5 : 0;\r\n    const scale = isSelected ? 1.1 : 1.0;\r\n\r\n    ctx.save();\r\n    ctx.translate(x, y + hover);\r\n    ctx.scale(scale, scale);\r\n\r\n    if (isLocked) {\r\n      ctx.globalAlpha = 0.5;\r\n    }\r\n\r\n    // Mobile: tap glow on unlocked cards\r\n    if (isMobileScreen && !isLocked) {\r\n      const tapGlowAlpha = 0.08 + Math.sin(time * 3 + i) * 0.06;\r\n      ctx.fillStyle = `rgba(80, 160, 255, ${tapGlowAlpha})`;\r\n      ctx.fillRect(-cardW / 2 - 5, -cardH / 2 - 5, cardW + 10, cardH + 10);\r\n    }\r\n\r\n    // Card Background\r\n    const cardGrad = ctx.createLinearGradient(0, -cardH / 2, 0, cardH / 2);\r\n    if (isLocked) {\r\n      cardGrad.addColorStop(0, '#0a0a0a');\r\n      cardGrad.addColorStop(1, '#050505');\r\n    } else {\r\n      cardGrad.addColorStop(0, isSelected ? '#1a2a3a' : '#111111');\r\n      cardGrad.addColorStop(1, isSelected ? '#0a0f1a' : '#050505');\r\n    }\r\n\r\n    ctx.fillStyle = cardGrad;\r\n    ctx.strokeStyle = isSelected ? (isLocked ? '#666' : '#ffffff') : '#333333';\r\n    ctx.lineWidth = isSelected ? 2 : 1;\r\n\r\n    ctx.fillRect(-cardW / 2, -cardH / 2, cardW, cardH);\r\n    ctx.strokeRect(-cardW / 2, -cardH / 2, cardW, cardH);\r\n\r\n    // Weapon Preview\r\n    ctx.save();\r\n    ctx.translate(0, -cardH / 2 + (isMobileScreen ? 42 : 55));\r\n    ctx.rotate(-Math.PI / 4);\r\n    if (isLocked) {\r\n      ctx.filter = 'grayscale(100%) brightness(50%)';\r\n    }\r\n    const pDummy = { weapon: opt.id } as any;\r\n    drawEquippedWeapon(ctx, pDummy, isMobileScreen ? 30 : 40, 0, time);\r\n    ctx.restore();\r\n\r\n    // Lock Icon\r\n    if (isLocked) {\r\n      ctx.fillStyle = '#ff4444';\r\n      ctx.textAlign = 'center';\r\n      ctx.font = `${isMobileScreen ? 13 : 16}px serif`;\r\n      ctx.fillText('­ƒöÆ', 0, 0);\r\n    }\r\n\r\n    // Text Label\r\n    ctx.fillStyle = isSelected ? (isLocked ? '#888' : '#ffffff') : '#444444';\r\n    ctx.font = `bold ${isMobileScreen ? 11 : 13}px ${C.HUD_FONT}`;\r\n    ctx.fillText(opt.name.toUpperCase(), 0, cardH / 2 - (isMobileScreen ? 22 : 30));\r\n\r\n    ctx.fillStyle = isSelected ? (isLocked ? '#555' : '#33ccff') : '#333333';\r\n    ctx.font = `${isMobileScreen ? 8 : 9}px ${C.HUD_FONT}`;\r\n    ctx.fillText(opt.desc, 0, cardH / 2 - (isMobileScreen ? 10 : 15));\r\n\r\n    // Mobile TAP hint\r\n    if (isMobileScreen && !isLocked) {\r\n      ctx.fillStyle = `rgba(100, 200, 255, ${0.5 + Math.sin(time * 4) * 0.3})`;\r\n      ctx.font = `7px ${C.HUD_FONT}`;\r\n      ctx.fillText('Ôû╝ TOQUE', 0, cardH / 2 - 1);\r\n    }\r\n\r\n    ctx.restore();\r\n  });\r\n}\r\n\r\n\r\nexport function renderEnemy(ctx: CanvasRenderingContext2D, e: EnemyState, time: number) {\r\n  // Never render dead enemies ÔÇö they must be removed from the list before rendering\r\n  if (e.isDying) return;\r\n\r\n  if (e.spawnTimer > 0) {\r\n    // Spawn animation - growing circle\r\n    const progress = 1 - (e.spawnTimer / 0.4);\r\n    ctx.fillStyle = `rgba(255, 100, 100, ${0.3 * (1 - progress)})`;\r\n    ctx.beginPath();\r\n    ctx.arc(e.x, e.y, 15 * (1 - progress), 0, Math.PI * 2);\r\n    ctx.fill();\r\n    return;\r\n  }\r\n\r\n  const x = Math.floor(e.x);\r\n  const y = Math.floor(e.y);\r\n  const s = e.width;\r\n  const half = Math.floor(s / 2);\r\n\r\n  // Apply wraith alpha\r\n  if (e.type === 'wraith') {\r\n    ctx.globalAlpha = e.phaseAlpha;\r\n  }\r\n\r\n  // Hit jitter / bulge\r\n  if (e.flashTime > 0) {\r\n    // No jitter or scaling as per user request (\"nada de distor├º├úo ou mexida\")\r\n    // Just the flash effect (handlers below) is enough feedback\r\n  }\r\n\r\n  // Shadow\r\n  ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';\r\n  ctx.fillRect(x - half + 1, y + half - 1, s - 2, 2);\r\n\r\n  if (e.isDying) {\r\n    ctx.fillStyle = '#1a0033'; // Deep dimensional purple\r\n  } else if (e.flashTime > 0) {\r\n    ctx.fillStyle = C.COLORS.white;\r\n  } else {\r\n    const colorMap: Record<string, string> = {\r\n      chaser: C.COLORS.chaser, shooter: C.COLORS.shooter,\r\n      tank: C.COLORS.tank, boss: C.COLORS.boss,\r\n      wraith: C.COLORS.wraith, bomber: C.COLORS.bomber,\r\n      swarm: C.COLORS.swarm, necromancer: C.COLORS.necromancer,\r\n      stalker: C.COLORS.stalker, phantom: '#ff00ff',\r\n      flash_hunter: C.COLORS.flashHunter, distortion: C.COLORS.distortion,\r\n      flicker_fiend: C.COLORS.flickerFiend, warper: C.COLORS.warper,\r\n      accelerator: C.COLORS.accelerator,\r\n    };\r\n    ctx.fillStyle = colorMap[e.type] || C.COLORS.chaser;\r\n  }\r\n\r\n  switch (e.type) {\r\n    case 'chaser': {\r\n      // ÔòÉÔòÉÔòÉ UMBRAL PROWLER - O Predador de Seda Negra ÔòÉÔòÉÔòÉ\r\n      const prowl = Math.sin(time * 12) * 2;\r\n      const tailFlow = Math.sin(time * 6) * 5;\r\n\r\n      // SLEEK SILHOUETTE (Elongated body)\r\n      const cColor = e.flashTime > 0 ? C.COLORS.white : '#0a0a0a';\r\n      ctx.fillStyle = cColor;\r\n\r\n      // Main Torso (Elegant teardrop shape)\r\n      ctx.beginPath();\r\n      ctx.moveTo(x - half - 4, y + prowl);\r\n      ctx.quadraticCurveTo(x, y - half - 2 + prowl, x + half + 4, y + prowl);\r\n      ctx.quadraticCurveTo(x, y + half + 2 + prowl, x - half - 4, y + prowl);\r\n      ctx.fill();\r\n\r\n      // BLADE LIMBS (4 Sharp, elegant legs)\r\n      ctx.strokeStyle = '#220000';\r\n      ctx.lineWidth = 1.2;\r\n      for (let i = 0; i < 2; i++) {\r\n        const side = i === 0 ? -1 : 1;\r\n        // Legs\r\n        ctx.beginPath();\r\n        ctx.moveTo(x + (side * 4), y + prowl);\r\n        ctx.lineTo(x + (side * 8), y + half + 6 + prowl);\r\n        ctx.stroke();\r\n      }\r\n\r\n      // ELEGANT TAIL (Wispy shadow)\r\n      ctx.strokeStyle = 'rgba(60, 0, 0, 0.4)';\r\n      ctx.beginPath();\r\n      ctx.moveTo(x - half, y + prowl);\r\n      ctx.bezierCurveTo(x - half - 10, y + prowl - 5, x - half - 5, y + prowl + 10, x - half - 15, y + prowl + tailFlow);\r\n      ctx.stroke();\r\n\r\n      // THE KILLING EYE (Single sharp red glint)\r\n      ctx.fillStyle = '#ff0000';\r\n      ctx.beginPath();\r\n      ctx.arc(x + half + 1, y + prowl - 1, 1.5, 0, Math.PI * 2);\r\n      ctx.fill();\r\n\r\n      // Eye glint aura\r\n      ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';\r\n      ctx.beginPath();\r\n      ctx.arc(x + half + 1, y + prowl - 1, 4, 0, Math.PI * 2);\r\n      ctx.fill();\r\n\r\n      break;\r\n    }\r\n\r\n    case 'shooter': {\r\n      // ÔòÉÔòÉÔòÉ ARCANE SENTINEL - Rel├¡quia Flutuante Elegante ÔòÉÔòÉÔòÉ\r\n      const float = Math.sin(time * 4) * 5;\r\n      const innerSpin = time * 2;\r\n      const pulsing = Math.sin(time * 6) * 0.2 + 0.8;\r\n\r\n      // 1. GOLDEN ORBITAL RINGS (Clean circular geometry)\r\n      ctx.strokeStyle = 'rgba(255, 215, 0, 0.4)';\r\n      ctx.lineWidth = 1;\r\n      for (let i = 0; i < 2; i++) {\r\n        const ringScale = i === 0 ? 1 : 0.7;\r\n        ctx.beginPath();\r\n        ctx.ellipse(x, y + float, half + 8, (half + 8) * 0.4, innerSpin * (i === 0 ? 1 : -1), 0, Math.PI * 2);\r\n        ctx.stroke();\r\n      }\r\n\r\n      // 2. THE FLOATING CROWN / SHARDS\r\n      ctx.fillStyle = '#111';\r\n      for (let i = 0; i < 3; i++) {\r\n        const ang = (i / 3) * Math.PI * 2 + innerSpin;\r\n        const sx = x + Math.cos(ang) * (half + 2);\r\n        const sy = y + Math.sin(ang) * (half + 2) * 0.5 + float;\r\n\r\n        ctx.beginPath();\r\n        ctx.moveTo(sx, sy - 3);\r\n        ctx.lineTo(sx + 2, sy);\r\n        ctx.lineTo(sx, sy + 3);\r\n        ctx.lineTo(sx - 2, sy);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n        ctx.fillStyle = '#88ccff';\r\n        ctx.fillRect(sx - 0.5, sy - 0.5, 1, 1);\r\n        ctx.fillStyle = '#111';\r\n      }\r\n\r\n      // 3. SAPPHIRE CORE (Main Body)\r\n      const coreGrad = ctx.createRadialGradient(x, y + float, 0, x, y + float, half);\r\n      coreGrad.addColorStop(0, e.flashTime > 0 ? C.COLORS.white : '#88ccff');\r\n      coreGrad.addColorStop(1, e.flashTime > 0 ? C.COLORS.white : '#1a0033');\r\n      ctx.fillStyle = coreGrad;\r\n\r\n      // Unique refined shape: Sharp diamond\r\n      ctx.beginPath();\r\n      ctx.moveTo(x, y - half - 4 + float);\r\n      ctx.lineTo(x + half, y + float);\r\n      ctx.lineTo(x, y + half + 4 + float);\r\n      ctx.lineTo(x - half, y + float);\r\n      ctx.closePath();\r\n      ctx.fill();\r\n\r\n      // 4. INNER ENERGY (Horizontal slit eye)\r\n      ctx.fillStyle = `rgba(255, 255, 255, ${pulsing})`;\r\n      ctx.fillRect(x - 3, y - 0.5 + float, 6, 1);\r\n\r\n      break;\r\n    }\r\n\r\n    case 'tank': {\r\n      // ÔòÉÔòÉÔòÉ ROYAL SENTINEL - O Guardi├úo Imponente ÔòÉÔòÉÔòÉ\r\n      const sway = Math.sin(time * 3) * 1;\r\n      const charge = e.aiState === 'charge';\r\n      const power = charge ? Math.sin(time * 20) * 0.3 + 0.7 : 0.4;\r\n\r\n      // 1. DARK STEEL CHASSIS (Clean plate armor)\r\n      const armorColor = e.flashTime > 0 ? C.COLORS.white : '#1a1a1a';\r\n      ctx.fillStyle = armorColor;\r\n\r\n      // Main heavy body (U-shape armor)\r\n      ctx.beginPath();\r\n      ctx.moveTo(x - half - 4, y + half);\r\n      ctx.lineTo(x - half - 4, y - half + 8);\r\n      ctx.quadraticCurveTo(x, y - half - 8 + sway, x + half + 4, y - half + 8);\r\n      ctx.lineTo(x + half + 4, y + half);\r\n      ctx.closePath();\r\n      ctx.fill();\r\n\r\n      // 2. GOLDEN FILIGREE (Elegant strategic detail)\r\n      ctx.strokeStyle = '#ffd700';\r\n      ctx.lineWidth = 1.5;\r\n      ctx.beginPath();\r\n      ctx.moveTo(x - half + 2, y);\r\n      ctx.lineTo(x + half - 2, y);\r\n      ctx.stroke();\r\n\r\n      // 3. ROYAL KITE SHIELD (Frontal presence)\r\n      ctx.fillStyle = e.flashTime > 0 ? C.COLORS.white : '#2a2a2a';\r\n      ctx.beginPath();\r\n      ctx.moveTo(x + half - 2, y - half + 5 + sway);\r\n      ctx.lineTo(x + half + 10, y - half + 5 + sway);\r\n      ctx.lineTo(x + half + 8, y + half + 5 + sway);\r\n      ctx.lineTo(x + half - 2, y + half + 2 + sway);\r\n      ctx.closePath();\r\n      ctx.fill();\r\n\r\n      // Shield Crest (Gold diamond)\r\n      ctx.fillStyle = '#ffd700';\r\n      ctx.beginPath();\r\n      ctx.moveTo(x + half + 4, y + sway);\r\n      ctx.lineTo(x + half + 6, y + 2 + sway);\r\n      ctx.lineTo(x + half + 4, y + 4 + sway);\r\n      ctx.lineTo(x + half + 2, y + 2 + sway);\r\n      ctx.closePath();\r\n      ctx.fill();\r\n\r\n      // 4. DIVINE PRESENCE (Charge effects - elegant sparks)\r\n      if (charge) {\r\n        ctx.strokeStyle = `rgba(255, 200, 0, ${power})`;\r\n        ctx.lineWidth = 2;\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, half + 15, 0, Math.PI * 2);\r\n        ctx.stroke();\r\n      }\r\n\r\n      // 5. HELMET SLIT (Menacing visor)\r\n      ctx.fillStyle = charge ? '#ff0000' : '#ffd700';\r\n      ctx.fillRect(x - 4, y - half + 4 + sway, 8, 2);\r\n\r\n      break;\r\n    }\r\n\r\n    case 'wraith': {\r\n      // ÔòÉÔòÉÔòÉ ETHEREAL SPECTER - Espectro dimensional ÔòÉÔòÉÔòÉ\r\n      const wFloat = Math.sin(time * 5 + e.x) * 3;\r\n      const phasePulse = Math.sin(time * 4) * 0.3 + 0.7;\r\n      const phaseShift = e.aiState === 'teleport' ? e.phaseAlpha : 1;\r\n\r\n      ctx.globalAlpha = phaseShift;\r\n\r\n      // Dimensional rift effect (when teleporting)\r\n      if (e.aiState === 'teleport' && e.phaseAlpha < 0.5) {\r\n        for (let i = 0; i < 5; i++) {\r\n          const riftAngle = (i / 5) * Math.PI * 2 + time * 4;\r\n          const riftDist = 8 + (0.5 - e.phaseAlpha) * 20;\r\n          const rx = x + Math.cos(riftAngle) * riftDist;\r\n          const ry = y + Math.sin(riftAngle) * riftDist + wFloat;\r\n\r\n          ctx.strokeStyle = `rgba(0, 255, 220, ${0.6 - e.phaseAlpha})`;\r\n          ctx.lineWidth = 2;\r\n          ctx.beginPath();\r\n          ctx.moveTo(x, y + wFloat);\r\n          ctx.lineTo(rx, ry);\r\n          ctx.stroke();\r\n        }\r\n\r\n        // Portal ring\r\n        ctx.strokeStyle = `rgba(0, 200, 200, ${0.8 - e.phaseAlpha})`;\r\n        ctx.lineWidth = 3;\r\n        ctx.beginPath();\r\n        ctx.arc(x, y + wFloat, 15 + (0.5 - e.phaseAlpha) * 15, 0, Math.PI * 2);\r\n        ctx.stroke();\r\n      }\r\n\r\n      // Outer spectral aura (multiple layers)\r\n      for (let layer = 0; layer < 3; layer++) {\r\n        const layerOffset = layer * 4;\r\n        const layerAlpha = (0.15 - layer * 0.04) * phasePulse;\r\n        ctx.fillStyle = `rgba(0, 220, 200, ${layerAlpha})`;\r\n        ctx.beginPath();\r\n        ctx.arc(x, y + wFloat, half + 10 + layerOffset, 0, Math.PI * 2);\r\n        ctx.fill();\r\n      }\r\n\r\n      // Spectral rings orbiting\r\n      for (let i = 0; i < 3; i++) {\r\n        const ringAngle = time * 3 + i * (Math.PI * 2 / 3);\r\n        const ringRadius = half + 8 + Math.sin(time * 2 + i) * 2;\r\n        ctx.strokeStyle = `rgba(0, 255, 200, ${0.3 * phasePulse})`;\r\n        ctx.lineWidth = 1;\r\n        ctx.beginPath();\r\n        ctx.arc(x + Math.cos(ringAngle) * 3, y + Math.sin(ringAngle) * 2 + wFloat, ringRadius, 0, Math.PI * 2);\r\n        ctx.stroke();\r\n      }\r\n\r\n      // Main ethereal body (translucent core)\r\n      const bodyGrad = ctx.createRadialGradient(x, y + wFloat, 0, x, y + wFloat, half + 2);\r\n      bodyGrad.addColorStop(0, e.flashTime > 0 ? C.COLORS.white : 'rgba(150, 255, 255, 0.9)');\r\n      bodyGrad.addColorStop(0.5, e.flashTime > 0 ? C.COLORS.white : C.COLORS.wraith);\r\n      bodyGrad.addColorStop(1, e.flashTime > 0 ? 'rgba(255, 255, 255, 0.3)' : 'rgba(0, 200, 200, 0.2)');\r\n      ctx.fillStyle = bodyGrad;\r\n      ctx.beginPath();\r\n      ctx.arc(x, y + wFloat, half + 1, 0, Math.PI * 2);\r\n      ctx.fill();\r\n\r\n      // Inner etheric glow (pulsating core)\r\n      const innerGlow = ctx.createRadialGradient(x, y + wFloat, 0, x, y + wFloat, half * 0.6);\r\n      innerGlow.addColorStop(0, `rgba(200, 255, 255, ${phasePulse * 0.8})`);\r\n      innerGlow.addColorStop(0.7, `rgba(100, 255, 255, ${phasePulse * 0.4})`);\r\n      innerGlow.addColorStop(1, 'rgba(0, 200, 200, 0)');\r\n      ctx.fillStyle = innerGlow;\r\n      ctx.beginPath();\r\n      ctx.arc(x, y + wFloat, half * 0.6, 0, Math.PI * 2);\r\n      ctx.fill();\r\n\r\n      // Spectral chains/tendrils flowing down\r\n      ctx.strokeStyle = e.flashTime > 0 ? C.COLORS.white : C.COLORS.wraithDark;\r\n      ctx.lineWidth = 1.5;\r\n      for (let i = 0; i < 5; i++) {\r\n        const tendrilX = x - 8 + i * 4;\r\n        const tendrilLength = 8 + i * 1.5;\r\n        const wave = Math.sin(time * 6 + i * 0.5) * 2;\r\n\r\n        ctx.globalAlpha = phaseShift * (1 - i * 0.15);\r\n        ctx.beginPath();\r\n        ctx.moveTo(tendrilX, y + half + wFloat);\r\n        ctx.quadraticCurveTo(\r\n          tendrilX + wave, y + half + wFloat + tendrilLength / 2,\r\n          tendrilX + wave * 2, y + half + wFloat + tendrilLength\r\n        );\r\n        ctx.stroke();\r\n      }\r\n\r\n      ctx.globalAlpha = phaseShift;\r\n\r\n      // Haunting eyes (piercing cyan glow)\r\n      const eyePulse = Math.sin(time * 8) * 0.2 + 0.8;\r\n      ctx.fillStyle = `rgba(0, 255, 255, ${eyePulse})`;\r\n      ctx.fillRect(x - 4, y - 2 + wFloat, 2, 3);\r\n      ctx.fillRect(x + 3, y - 2 + wFloat, 2, 3);\r\n\r\n      // Eye glow aura\r\n      ctx.fillStyle = `rgba(0, 255, 220, ${eyePulse * 0.4})`;\r\n      ctx.fillRect(x - 6, y - 3 + wFloat, 6, 5);\r\n      ctx.fillRect(x + 1, y - 3 + wFloat, 6, 5);\r\n\r\n      // Ethereal particles drifting\r\n      for (let i = 0; i < 4; i++) {\r\n        if (Math.random() < 0.3) {\r\n          const px = x + (Math.random() - 0.5) * (s + 10);\r\n          const py = y + wFloat + (Math.random() - 0.5) * (s + 10);\r\n          ctx.fillStyle = `rgba(0, ${200 + Math.random() * 55}, 220, ${0.4 + Math.random() * 0.4})`;\r\n          ctx.fillRect(px, py, 1, 1);\r\n        }\r\n      }\r\n\r\n      ctx.globalAlpha = 1;\r\n      break;\r\n    }\r\n\r\n    case 'bomber': {\r\n      // ÔòÉÔòÉÔòÉ OBSIDIAN HEART - O N├║cleo de Magia Inst├ível ÔòÉÔòÉÔòÉ\r\n      const active = e.aiState === 'fuse';\r\n      const float = Math.sin(time * 5) * 2;\r\n      const pulsing = active ? Math.sin(time * 25) * 0.4 + 0.6 : 0.4;\r\n      const crack = active ? (1 - e.fuseTimer / 1.5) : 0;\r\n\r\n      // 1. DARK ENERGY LEAK (Aura)\r\n      if (active) {\r\n        ctx.fillStyle = `rgba(100, 0, 255, ${0.15 * pulsing})`;\r\n        ctx.beginPath();\r\n        ctx.arc(x, y + float, half + 10 + crack * 15, 0, Math.PI * 2);\r\n        ctx.fill();\r\n      }\r\n\r\n      // 2. FLOATING OBSIDIAN SHELL (Shattered look)\r\n      ctx.fillStyle = e.flashTime > 0 ? C.COLORS.white : '#080010';\r\n      for (let i = 0; i < 6; i++) {\r\n        const ang = (i / 6) * Math.PI * 2 + time * 0.5;\r\n        const dist = 6 + crack * 8;\r\n        const ox = x + Math.cos(ang) * dist;\r\n        const oy = y + Math.sin(ang) * dist + float;\r\n\r\n        ctx.save();\r\n        ctx.translate(ox, oy);\r\n        ctx.rotate(ang);\r\n        ctx.beginPath();\r\n        ctx.moveTo(-4, -6);\r\n        ctx.lineTo(4, -2);\r\n        ctx.lineTo(2, 6);\r\n        ctx.lineTo(-6, 2);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n        ctx.restore();\r\n      }\r\n\r\n      // 3. THE UNSTABLE CORE (Energy orb)\r\n      const coreGrad = ctx.createRadialGradient(x, y + float, 0, x, y + float, half - 2);\r\n      coreGrad.addColorStop(0, '#ffffff');\r\n      coreGrad.addColorStop(0.4, active ? '#ff00ff' : '#4400aa');\r\n      coreGrad.addColorStop(1, 'rgba(0,0,0,0)');\r\n      ctx.fillStyle = coreGrad;\r\n      ctx.beginPath();\r\n      ctx.arc(x, y + float, half - 2, 0, Math.PI * 2);\r\n      ctx.fill();\r\n\r\n      break;\r\n    }\r\n\r\n    case 'swarm': {\r\n      // ÔòÉÔòÉÔòÉ RAZOR WASP - Predador A├®reo Bio-Mec├ónico ÔòÉÔòÉÔòÉ\r\n      const hover = Math.sin(time * 10) * 3;\r\n      const wingBeat = Math.sin(time * 40);\r\n\r\n      // DOUBLE CRYSTAL WINGS\r\n      ctx.fillStyle = 'rgba(150, 200, 255, 0.4)';\r\n      // Left Wings\r\n      ctx.beginPath();\r\n      ctx.ellipse(x - 4, y + hover, 12, 4 + wingBeat * 3, -0.4, 0, Math.PI * 2);\r\n      ctx.fill();\r\n      // Right Wings\r\n      ctx.beginPath();\r\n      ctx.ellipse(x + 4, y + hover, 12, 4 + wingBeat * 3, 0.4, 0, Math.PI * 2);\r\n      ctx.fill();\r\n\r\n      // SHARP SEGMENTED BODY\r\n      const bodyColor = e.flashTime > 0 ? C.COLORS.white : '#ffd700';\r\n      ctx.fillStyle = bodyColor;\r\n\r\n      // Abdomen (Spear shape)\r\n      ctx.beginPath();\r\n      ctx.moveTo(x, y + hover - 2);\r\n      ctx.lineTo(x - 4, y + hover + 10);\r\n      ctx.lineTo(x, y + hover + 14); // The Stinger point\r\n      ctx.lineTo(x + 4, y + hover + 10);\r\n      ctx.closePath();\r\n      ctx.fill();\r\n\r\n      // Venom markings\r\n      ctx.fillStyle = '#111111';\r\n      ctx.fillRect(x - 3, y + hover + 4, 6, 1.5);\r\n      ctx.fillRect(x - 2, y + hover + 8, 4, 1.5);\r\n    }\r\n\r\n    case 'wraith': {\r\n      // ÔòÉÔòÉÔòÉ LOST SOUL - Espectro Dimensional ÔòÉÔòÉÔòÉ\r\n      const float = Math.sin(time * 4) * 5;\r\n      const alpha = e.phaseAlpha;\r\n      ctx.globalAlpha = alpha;\r\n\r\n      // Mist Trail\r\n      for (let i = 0; i < 4; i++) {\r\n        ctx.fillStyle = `rgba(0, 255, 200, ${(0.2 - i * 0.04) * alpha})`;\r\n        ctx.beginPath();\r\n        ctx.arc(x - e.vx * i * 3, y + float + 5 + i * 4, half - i, 0, Math.PI * 2);\r\n        ctx.fill();\r\n      }\r\n\r\n      // ETHEREAL BODY (Wispy)\r\n      const wColor = e.flashTime > 0 ? C.COLORS.white : 'rgba(0, 255, 200, 0.6)';\r\n      ctx.fillStyle = wColor;\r\n      ctx.beginPath();\r\n      ctx.moveTo(x, y - half + float);\r\n      ctx.quadraticCurveTo(x + half + 2, y + float, x, y + half + 6 + float);\r\n      ctx.quadraticCurveTo(x - half - 2, y + float, x, y - half + float);\r\n      ctx.fill();\r\n\r\n      // Hollow Eyes\r\n      ctx.fillStyle = '#000000';\r\n      ctx.beginPath();\r\n      ctx.ellipse(x - 3, y - 2 + float, 2, 4, 0, 0, Math.PI * 2);\r\n      ctx.fill();\r\n      ctx.beginPath();\r\n      ctx.ellipse(x + 3, y - 2 + float, 2, 4, 0, 0, Math.PI * 2);\r\n      ctx.fill();\r\n\r\n      ctx.globalAlpha = 1;\r\n      break;\r\n    }\r\n\r\n    case 'stalker': {\r\n      // ÔòÉÔòÉÔòÉ SHADOW ASSASSIN - Predador de L├óminas ÔòÉÔòÉÔòÉ\r\n      const crouch = Math.sin(time * 6) * 1;\r\n      const lunge = e.lunging ? 5 : 0;\r\n      ctx.globalAlpha = e.stealthAlpha;\r\n\r\n      // HUNCHED SILHOUETTE\r\n      const sColor = e.flashTime > 0 ? C.COLORS.white : '#111111';\r\n      ctx.fillStyle = sColor;\r\n\r\n      // Left Scythe Arm\r\n      ctx.beginPath();\r\n      ctx.moveTo(x - 2, y + crouch);\r\n      ctx.quadraticCurveTo(x - half - 8 - lunge, y - half + crouch, x - half - 12 - lunge, y + half + crouch);\r\n      ctx.lineTo(x - half - 6, y + half + 2 + crouch);\r\n      ctx.fill();\r\n\r\n      // Right Scythe Arm\r\n      ctx.beginPath();\r\n      ctx.moveTo(x + 2, y + crouch);\r\n      ctx.quadraticCurveTo(x + half + 8 + lunge, y - half + crouch, x + half + 12 + lunge, y + half + crouch);\r\n      ctx.lineTo(x + half + 6, y + half + 2 + crouch);\r\n      ctx.fill();\r\n\r\n      // Torso\r\n      ctx.beginPath();\r\n      ctx.moveTo(x - 5, y + half + crouch);\r\n      ctx.lineTo(x + 5, y + half + crouch);\r\n      ctx.lineTo(x, y - half + crouch);\r\n      ctx.closePath();\r\n      ctx.fill();\r\n\r\n      // Red Kill-Eyes\r\n      ctx.fillStyle = '#ff0000';\r\n      ctx.fillRect(x - 2, y - half + 4 + crouch, 1, 1);\r\n      ctx.fillRect(x + 1, y - half + 4 + crouch, 1, 1);\r\n\r\n      ctx.globalAlpha = 1;\r\n      break;\r\n    }\r\n\r\n    case 'phantom': {\r\n      // ÔòÉÔòÉÔòÉ WAILING BANSHEE - O Grito do Desespero ÔòÉÔòÉÔòÉ\r\n      const wail = Math.sin(time * 20) * 2;\r\n      ctx.globalAlpha = e.stealthAlpha;\r\n\r\n      // Ghostly Wisps\r\n      ctx.fillStyle = 'rgba(200, 100, 255, 0.3)';\r\n      for (let i = 0; i < 5; i++) {\r\n        const ang = (i / 5) * Math.PI * 2 + time;\r\n        ctx.beginPath();\r\n        ctx.arc(x + Math.cos(ang) * (half + 4), y + Math.sin(ang) * (half + 4), 3, 0, Math.PI * 2);\r\n        ctx.fill();\r\n      }\r\n\r\n      // SOUL MASS (Flowing)\r\n      const pColor = e.flashTime > 0 ? C.COLORS.white : 'rgba(255, 100, 255, 0.7)';\r\n      ctx.fillStyle = pColor;\r\n      ctx.beginPath();\r\n      ctx.moveTo(x, y - half - 5);\r\n      ctx.bezierCurveTo(x + half + 10, y, x + half, y + half + 10, x, y + half + 15);\r\n      ctx.bezierCurveTo(x - half, y + half + 10, x - half - 10, y, x, y - half - 5);\r\n      ctx.fill();\r\n\r\n      // The Agonized Face\r\n      ctx.fillStyle = '#000000';\r\n      // Eyes\r\n      ctx.beginPath();\r\n      ctx.arc(x - 4, y - 2, 3, 0, Math.PI * 2);\r\n      ctx.fill();\r\n      ctx.beginPath();\r\n      ctx.arc(x + 4, y - 2, 3, 0, Math.PI * 2);\r\n      ctx.fill();\r\n      // Screaming Mouth\r\n      ctx.beginPath();\r\n      ctx.ellipse(x, y + 6, 2, 5 + wail, 0, 0, Math.PI * 2);\r\n      ctx.fill();\r\n\r\n      ctx.globalAlpha = 1;\r\n      break;\r\n    }\r\n\r\n    case 'flash_hunter': {\r\n      // ÔòÉÔòÉÔòÉ LIGHT PRISM - O Ca├ºador de Cristais ÔòÉÔòÉÔòÉ\r\n      const spin = time * 4;\r\n      ctx.globalAlpha = e.stealthAlpha;\r\n\r\n      // CRYSTALLINE STRUCTURE (Hexagonal)\r\n      const fColor = e.flashTime > 0 ? C.COLORS.white : '#ffffff';\r\n      ctx.fillStyle = fColor;\r\n      ctx.strokeStyle = '#88ccff';\r\n      ctx.lineWidth = 1;\r\n\r\n      ctx.beginPath();\r\n      for (let i = 0; i < 6; i++) {\r\n        const ang = spin + (i * Math.PI / 3);\r\n        const px = x + Math.cos(ang) * half;\r\n        const py = y + Math.sin(ang) * half;\r\n        if (i === 0) ctx.moveTo(px, py);\r\n        else ctx.lineTo(px, py);\r\n      }\r\n      ctx.closePath();\r\n      ctx.fill();\r\n      ctx.stroke();\r\n\r\n      // INNER CORE\r\n      ctx.fillStyle = '#00ccff';\r\n      ctx.beginPath();\r\n      ctx.arc(x, y, 3, 0, Math.PI * 2);\r\n      ctx.fill();\r\n\r\n      ctx.globalAlpha = 1;\r\n      break;\r\n    }\r\n\r\n    case 'distortion': {\r\n      // ÔòÉÔòÉÔòÉ VOID MIRROR - O Fragmento da Realidade ÔòÉÔòÉÔòÉ\r\n      ctx.globalAlpha = e.stealthAlpha;\r\n      const float = Math.sin(time * 4) * 5;\r\n\r\n      // 1. DISTORTION HALO\r\n      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';\r\n      ctx.lineWidth = 1;\r\n      ctx.beginPath();\r\n      ctx.arc(x, y + float, half + 10, 0, Math.PI * 2);\r\n      ctx.stroke();\r\n\r\n      // 2. SHATTERED DARK GLASS (Clean geometric shards)\r\n      ctx.fillStyle = e.flashTime > 0 ? C.COLORS.white : '#050010';\r\n      for (let i = 0; i < 5; i++) {\r\n        const ang = (i / 5) * Math.PI * 2 + time;\r\n        const dist = 5 + Math.sin(time * 2 + i) * 3;\r\n        const sx = x + Math.cos(ang) * dist;\r\n        const sy = y + Math.sin(ang) * dist + float;\r\n\r\n        ctx.save();\r\n        ctx.translate(sx, sy);\r\n        ctx.rotate(ang + time);\r\n        ctx.beginPath();\r\n        ctx.moveTo(-3, -5);\r\n        ctx.lineTo(3, 0);\r\n        ctx.lineTo(-3, 5);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n\r\n        // Mirror rim light\r\n        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';\r\n        ctx.lineWidth = 0.5;\r\n        ctx.stroke();\r\n        ctx.restore();\r\n      }\r\n\r\n      // 3. THE VOID EYE (Single magenta slit)\r\n      ctx.fillStyle = '#ff00ff';\r\n      ctx.fillRect(x - 4, y - 1 + float, 8, 2);\r\n\r\n      ctx.globalAlpha = 1;\r\n      break;\r\n    }\r\n\r\n    case 'flicker_fiend': {\r\n      // ÔòÉÔòÉÔòÉ ABYSSAL WRAITH - O Ser Entre Quadros ÔòÉÔòÉÔòÉ\r\n      if (e.stealthAlpha < 0.5) break;\r\n      const opacity = 0.4 + Math.sin(time * 30) * 0.3;\r\n\r\n      // 1. GHOSTLY SILHOUETTE (Contrast-heavy)\r\n      ctx.fillStyle = e.flashTime > 0 ? C.COLORS.white : `rgba(10, 0, 20, ${opacity})`;\r\n\r\n      // Clean diamond body\r\n      ctx.beginPath();\r\n      ctx.moveTo(x, y - half - 10);\r\n      ctx.lineTo(x + half + 2, y);\r\n      ctx.lineTo(x, y + half + 10);\r\n      ctx.lineTo(x - half - 2, y);\r\n      ctx.closePath();\r\n      ctx.fill();\r\n\r\n      // 2. SHADOW FLICKER (Refined arcs of shadow)\r\n      ctx.strokeStyle = `rgba(255, 0, 50, ${opacity * 0.5})`;\r\n      ctx.lineWidth = 1;\r\n      for (let i = 0; i < 2; i++) {\r\n        const offset = Math.sin(time * 40 + i) * 10;\r\n        ctx.beginPath();\r\n        ctx.arc(x + offset, y, half + 5, 0, Math.PI * 2);\r\n        ctx.stroke();\r\n      }\r\n\r\n      // 3. PIERCING EYES (Steady yellow intensity)\r\n      ctx.fillStyle = '#ffff00';\r\n      ctx.fillRect(x - 3, y - 4, 1.5, 5);\r\n      ctx.fillRect(x + 1.5, y - 4, 1.5, 5);\r\n\r\n      break;\r\n    }\r\n\r\n    case 'warper': {\r\n      // ÔòÉÔòÉÔòÉ RIFT WALKER - M├¡stico do Espa├ºo-Tempo ÔòÉÔòÉÔòÉ\r\n      ctx.globalAlpha = e.stealthAlpha;\r\n      const float = Math.sin(time * 5) * 3;\r\n      const portal = (1 - e.stealthAlpha);\r\n\r\n      // Galaxy Shroud (Aura)\r\n      const gGrad = ctx.createRadialGradient(x, y + float, 0, x, y + float, half + 15);\r\n      gGrad.addColorStop(0, 'rgba(0, 50, 200, 0.4)');\r\n      gGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');\r\n      ctx.fillStyle = gGrad;\r\n      ctx.beginPath();\r\n      ctx.arc(x, y + float, half + 15, 0, Math.PI * 2);\r\n      ctx.fill();\r\n\r\n      // RIFT CLOAK (Flowing)\r\n      ctx.fillStyle = e.flashTime > 0 ? C.COLORS.white : '#001a33';\r\n      ctx.beginPath();\r\n      ctx.moveTo(x - half, y - half + float);\r\n      ctx.quadraticCurveTo(x, y - half - 5 + float, x + half, y - half + float);\r\n      ctx.lineTo(x + half + 4, y + half + float);\r\n      ctx.lineTo(x - half - 4, y + half + float);\r\n      ctx.closePath();\r\n      ctx.fill();\r\n\r\n      // CRYSTAL MASK\r\n      ctx.fillStyle = '#88ccff';\r\n      ctx.beginPath();\r\n      ctx.moveTo(x, y - half + 2 + float);\r\n      ctx.lineTo(x + 4, y - half + 8 + float);\r\n      ctx.lineTo(x, y - half + 12 + float);\r\n      ctx.lineTo(x - 4, y - half + 8 + float);\r\n      ctx.closePath();\r\n      ctx.fill();\r\n\r\n      // Teleport Rings\r\n      if (portal > 0.1) {\r\n        ctx.strokeStyle = `rgba(100, 200, 255, ${portal})`;\r\n        ctx.beginPath();\r\n        ctx.arc(x, y + float, half + 5 + portal * 20, 0, Math.PI * 2);\r\n        ctx.stroke();\r\n      }\r\n\r\n      ctx.globalAlpha = 1;\r\n      break;\r\n    }\r\n\r\n    case 'chaser': {\r\n      // ÔòÉÔòÉÔòÉ VOID WRAITH - Professional Spectral Entity ÔòÉÔòÉÔòÉ\r\n      const float = Math.sin(time * 4) * 5;\r\n      const pulse = 0.8 + Math.sin(time * 2) * 0.2;\r\n\r\n      // 1. ETHEREAL BASE (Wispy robes)\r\n      ctx.fillStyle = e.flashTime > 0 ? C.COLORS.white : (biome.theme === 'volcano' ? '#2a0505' : '#050a1a');\r\n      ctx.beginPath();\r\n      ctx.moveTo(x - half, y + half + float);\r\n      ctx.quadraticCurveTo(x - half - 5, y - half + float, x, y - half - 5 + float);\r\n      ctx.quadraticCurveTo(x + half + 5, y - half + float, x + half, y + half + float);\r\n      ctx.lineTo(x + half / 2, y + half - 5 + float);\r\n      ctx.lineTo(x, y + half + 2 + float);\r\n      ctx.lineTo(x - half / 2, y + half - 5 + float);\r\n      ctx.closePath();\r\n      ctx.fill();\r\n\r\n      // 2. INNER VOID (Deep shadow)\r\n      ctx.fillStyle = 'rgba(0,0,0,0.4)';\r\n      ctx.beginPath();\r\n      ctx.moveTo(x - half / 2, y + float);\r\n      ctx.lineTo(x + half / 2, y + float);\r\n      ctx.lineTo(x, y - half + float);\r\n      ctx.fill();\r\n\r\n      // 3. GLOWING GAZE (Matches biome accent)\r\n      ctx.shadowBlur = 8;\r\n      ctx.shadowColor = biome.accent;\r\n      ctx.fillStyle = '#ffffff';\r\n      const eyeW = 3 * pulse;\r\n      ctx.fillRect(x - 6, y - half / 2 + float, eyeW, 2);\r\n      ctx.fillRect(x + 6 - eyeW, y - half / 2 + float, eyeW, 2);\r\n      ctx.shadowBlur = 0;\r\n      break;\r\n    }\r\n\r\n    case 'ranged': {\r\n      // ÔòÉÔòÉÔòÉ GLINT SENTINEL - Crystalline Faceted Construct ÔòÉÔòÉÔòÉ\r\n      const hover = Math.sin(time * 2) * 3;\r\n      const crystalPulse = 0.5 + Math.sin(time * 4) * 0.5;\r\n\r\n      // 1. HARD SURFACE BODY (Faceted Diamond Shape)\r\n      ctx.fillStyle = e.flashTime > 0 ? C.COLORS.white : biome.wallTop;\r\n      ctx.beginPath();\r\n      ctx.moveTo(x, y - half - 5 + hover);\r\n      ctx.lineTo(x + half + 5, y + hover);\r\n      ctx.lineTo(x, y + half + 5 + hover);\r\n      ctx.lineTo(x - half - 5, y + hover);\r\n      ctx.closePath();\r\n      ctx.fill();\r\n\r\n      // 2. FACET SHADING\r\n      ctx.fillStyle = 'rgba(255,255,255,0.1)';\r\n      ctx.beginPath();\r\n      ctx.moveTo(x, y - half - 5 + hover);\r\n      ctx.lineTo(x + half + 5, y + hover);\r\n      ctx.lineTo(x, y + hover);\r\n      ctx.fill();\r\n\r\n      // 3. CORE ENERGY (Biome specific)\r\n      const cGrad = ctx.createRadialGradient(x, y + hover, 0, x, y + hover, 8);\r\n      cGrad.addColorStop(0, '#ffffff');\r\n      cGrad.addColorStop(1, biome.accent);\r\n      ctx.fillStyle = cGrad;\r\n      ctx.shadowBlur = 12 * crystalPulse;\r\n      ctx.shadowColor = biome.accent;\r\n      ctx.beginPath();\r\n      ctx.arc(x, y + hover, 5, 0, Math.PI * 2);\r\n      ctx.fill();\r\n      ctx.shadowBlur = 0;\r\n      break;\r\n    }\r\n\r\n    case 'accelerator': {\r\n      // ÔòÉÔòÉÔòÉ SPECTRAL BOLIDE - High-speed Energy Entity ÔòÉÔòÉÔòÉ\r\n      const speed = e.stealthAlpha; // Reusing internal state for visual speed\r\n      const stretch = 15 * speed;\r\n\r\n      // 1. DYNAMIC ENERGY TRAIL\r\n      const tGrad = ctx.createLinearGradient(x - half - stretch - 20, y, x, y);\r\n      tGrad.addColorStop(0, 'rgba(0,0,0,0)');\r\n      tGrad.addColorStop(1, biome.accentGlow.replace('0.2', '0.6'));\r\n      ctx.fillStyle = tGrad;\r\n      ctx.beginPath();\r\n      ctx.moveTo(x - half - 30 - stretch, y);\r\n      ctx.lineTo(x, y - half);\r\n      ctx.lineTo(x, y + half);\r\n      ctx.closePath();\r\n      ctx.fill();\r\n\r\n      // 2. PROJECTILE CORE (Needle)\r\n      ctx.fillStyle = e.flashTime > 0 ? C.COLORS.white : (biome.theme === 'volcano' ? '#1a0505' : '#05051a');\r\n      ctx.beginPath();\r\n      ctx.moveTo(x + half + 10, y);\r\n      ctx.lineTo(x - half - stretch, y - 4);\r\n      ctx.lineTo(x - half - stretch, y + 4);\r\n      ctx.closePath();\r\n      ctx.fill();\r\n\r\n      // 3. WAKE SPARK (Rim highlight)\r\n      ctx.strokeStyle = '#ffffff';\r\n      ctx.lineWidth = 1;\r\n      ctx.globalAlpha = 0.3;\r\n      ctx.stroke();\r\n      ctx.globalAlpha = 1;\r\n      break;\r\n    }\r\n\r\n    case 'boss': {\r\n      const breathe = Math.sin(time * 2) * 1;\r\n      // Import floor from bosses module\r\n      const bossFloor = (window as any).__bossFloor || 1;\r\n\r\n      switch (bossFloor) {\r\n        case 2: {\r\n          // ÔòÉÔòÉÔòÉ CELESTIAL GOLDEN HUNTER - O Ca├ºador Divino ÔòÉÔòÉÔòÉ\r\n          const float = Math.sin(time * 3) * 4;\r\n          const spearPulse = Math.sin(time * 10) * 0.2 + 0.8;\r\n          const capeMotion = Math.sin(time * 5) * 5;\r\n          const powerLevel = Math.sin(time * 2) * 0.2 + 0.8;\r\n\r\n          // Divine Golden Aura\r\n          const divineGlow = ctx.createRadialGradient(x, y + float, 0, x, y + float, half + 30);\r\n          divineGlow.addColorStop(0, `rgba(255, 215, 0, ${0.3 * powerLevel})`);\r\n          divineGlow.addColorStop(0.5, `rgba(255, 150, 0, 0.1)`);\r\n          divineGlow.addColorStop(1, 'rgba(255, 100, 0, 0)');\r\n          ctx.fillStyle = divineGlow;\r\n          ctx.fillRect(x - half - 30, y - half - 30 + float, s + 60, s + 60);\r\n\r\n          // Ethereal Cape (Flowing energy)\r\n          ctx.fillStyle = 'rgba(255, 180, 0, 0.4)';\r\n          ctx.beginPath();\r\n          ctx.moveTo(x - 2, y - half + float);\r\n          ctx.bezierCurveTo(x - 15 - capeMotion, y + half + float, x - 5, y + half + 20 + float, x - 20, y + half + 25 + float);\r\n          ctx.lineTo(x + 5, y + half + 10 + float);\r\n          ctx.closePath();\r\n          ctx.fill();\r\n\r\n          // Body Structure - Agile Warrior Silhouette (Less Boxy)\r\n          const armorColor = e.flashTime > 0 ? C.COLORS.white : '#e6b800';\r\n          ctx.fillStyle = armorColor;\r\n\r\n          // Torso (Curved armor)\r\n          ctx.beginPath();\r\n          ctx.moveTo(x, y - half + float);\r\n          ctx.quadraticCurveTo(x + 8, y - half + 10 + float, x + 4, y + half - 2 + float);\r\n          ctx.lineTo(x - 4, y + half - 2 + float);\r\n          ctx.quadraticCurveTo(x - 8, y - half + 10 + float, x, y - half + float);\r\n          ctx.fill();\r\n\r\n          // Pauldrons (Shoulder pads)\r\n          ctx.fillStyle = e.flashTime > 0 ? C.COLORS.white : '#ffcc00';\r\n          ctx.beginPath();\r\n          ctx.ellipse(x - 6, y - half + 5 + float, 5, 3, Math.PI / 4, 0, Math.PI * 2);\r\n          ctx.fill();\r\n          ctx.beginPath();\r\n          ctx.ellipse(x + 6, y - half + 5 + float, 5, 3, -Math.PI / 4, 0, Math.PI * 2);\r\n          ctx.fill();\r\n\r\n          // Helmet / Head\r\n          ctx.fillStyle = armorColor;\r\n          ctx.beginPath();\r\n          ctx.ellipse(x, y - half - 2 + float, 5, 6, 0, 0, Math.PI * 2);\r\n          ctx.fill();\r\n\r\n          // Energy Crest (Plume)\r\n          ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\r\n          ctx.beginPath();\r\n          ctx.moveTo(x, y - half - 8 + float);\r\n          ctx.quadraticCurveTo(x + 10, y - half - 15 + float, x + 2, y - half - 4 + float);\r\n          ctx.fill();\r\n\r\n          // Eyes of Light\r\n          ctx.fillStyle = '#ffffff';\r\n          ctx.fillRect(x - 3, y - half + 1 + float, 2, 2);\r\n          ctx.fillRect(x + 1, y - half + 1 + float, 2, 2);\r\n\r\n          // ÔòÉÔòÉÔòÉ THE GOLDEN ENERGY SPEAR ÔòÉÔòÉÔòÉ\r\n          const spearX = x + 12;\r\n          const spearY = y + float;\r\n          const spearLen = 45;\r\n\r\n          // Spear shadow/glow\r\n          ctx.strokeStyle = `rgba(255, 200, 0, ${0.4 * spearPulse})`;\r\n          ctx.lineWidth = 4;\r\n          ctx.beginPath();\r\n          ctx.moveTo(spearX, spearY - spearLen / 2);\r\n          ctx.lineTo(spearX, spearY + spearLen / 2);\r\n          ctx.stroke();\r\n\r\n          // Main Spear Shaft\r\n          ctx.strokeStyle = '#ffffff';\r\n          ctx.lineWidth = 1.5;\r\n          ctx.beginPath();\r\n          ctx.moveTo(spearX, spearY - spearLen / 2);\r\n          ctx.lineTo(spearX, spearY + spearLen / 2);\r\n          ctx.stroke();\r\n\r\n          // Spear Tip (Energy blade)\r\n          ctx.fillStyle = '#ffffff';\r\n          ctx.beginPath();\r\n          ctx.moveTo(spearX, spearY - spearLen / 2 - 10);\r\n          ctx.lineTo(spearX + 4, spearY - spearLen / 2);\r\n          ctx.lineTo(spearX - 4, spearY - spearLen / 2);\r\n          ctx.closePath();\r\n          ctx.fill();\r\n\r\n          // Sparking energy around spear\r\n          for (let i = 0; i < 3; i++) {\r\n            const sx = spearX + (Math.random() - 0.5) * 10;\r\n            const sy = spearY - spearLen / 2 + Math.random() * spearLen;\r\n            ctx.fillStyle = '#fffae6';\r\n            ctx.fillRect(sx, sy, 2, 2);\r\n          }\r\n\r\n          // Floating shards of light\r\n          for (let i = 0; i < 5; i++) {\r\n            const ang = (time * 2 + i) % (Math.PI * 2);\r\n            const dist = half + 15 + Math.sin(time + i) * 5;\r\n            const px = x + Math.cos(ang) * dist;\r\n            const py = y + Math.sin(ang) * dist + float;\r\n            ctx.fillStyle = `rgba(255, 255, 200, ${0.6})`;\r\n            ctx.save();\r\n            ctx.translate(px, py);\r\n            ctx.rotate(time + i);\r\n            ctx.fillRect(-2, -2, 4, 4);\r\n            ctx.restore();\r\n          }\r\n\r\n          break;\r\n        }\r\n        case 3: {\r\n          // ÔòÉÔòÉÔòÉ THE SOUL SOVEREIGN (THE INVOKER) ÔòÉÔòÉÔòÉ\r\n          const float = Math.sin(time * 3) * 6;\r\n          const power = Math.sin(time * 5) * 0.2 + 0.8;\r\n          const pulse = Math.sin(time * 2) * 0.3 + 0.7;\r\n          const magicSpin = time * 1.5;\r\n\r\n          // 1. DARK ENERGY VORTEX (Center presence)\r\n          const vortexGrad = ctx.createRadialGradient(x, y + float, 0, x, y + float, half + 20);\r\n          vortexGrad.addColorStop(0, `rgba(80, 0, 160, ${0.4 * power})`);\r\n          vortexGrad.addColorStop(0.5, `rgba(40, 0, 80, ${0.2 * pulse})`);\r\n          vortexGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');\r\n          ctx.fillStyle = vortexGrad;\r\n          ctx.beginPath();\r\n          ctx.arc(x, y + float, half + 45, 0, Math.PI * 2);\r\n          ctx.fill();\r\n\r\n          // 2. MYSTICAL AURA (Invoker presence)\r\n          ctx.save();\r\n          ctx.translate(x, y + float);\r\n          for (let i = 0; i < 4; i++) {\r\n            const rot = magicSpin + (i * Math.PI / 2);\r\n            ctx.rotate(rot);\r\n            const grad = ctx.createLinearGradient(0, 0, 0, half + 40);\r\n            grad.addColorStop(0, `rgba(120, 40, 255, ${0.35 * pulse})`);\r\n            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');\r\n            ctx.fillStyle = grad;\r\n            ctx.beginPath();\r\n            ctx.moveTo(-14, 0);\r\n            ctx.quadraticCurveTo(0, half + 50, 14, 0);\r\n            ctx.fill();\r\n          }\r\n          ctx.restore();\r\n\r\n          // 3. REGAL SILHOUETTE (Intercalating Black and Purple)\r\n          const hoodColor = e.flashTime > 0 ? C.COLORS.white : '#05000a';\r\n          const robeColor = e.flashTime > 0 ? C.COLORS.white : '#1a0033'; // Dark purple instead of pure black\r\n          ctx.fillStyle = robeColor;\r\n\r\n          // More Elegant Hood and Tapered Robes\r\n          ctx.beginPath();\r\n          ctx.moveTo(x - half - 10, y + half + 25 + float);\r\n          ctx.quadraticCurveTo(x - half - 18, y - half + float, x, y - half - 35 + float);\r\n          ctx.quadraticCurveTo(x + half + 18, y - half + float, x + half + 10, y + half + 25 + float);\r\n          ctx.quadraticCurveTo(x, y + half + 20 + float, x - half - 10, y + half + 25 + float);\r\n          ctx.fill();\r\n\r\n          // Inner Hood (Deep black for mystery)\r\n          ctx.fillStyle = hoodColor;\r\n          ctx.beginPath();\r\n          ctx.moveTo(x - 12, y - half + 5 + float);\r\n          ctx.quadraticCurveTo(x, y - half - 25 + float, x + 12, y - half + 5 + float);\r\n          ctx.lineTo(x, y - half + 15 + float);\r\n          ctx.closePath();\r\n          ctx.fill();\r\n\r\n          // Inner Robe Flow (Vibrant purple shadow folds)\r\n          ctx.strokeStyle = `rgba(180, 50, 255, ${0.6 * pulse})`;\r\n          ctx.lineWidth = 1.5;\r\n          for (let i = -1; i <= 1; i++) {\r\n            ctx.beginPath();\r\n            ctx.moveTo(x + i * 5, y - half + 10 + float);\r\n            ctx.quadraticCurveTo(x + i * 12, y + half + 15 + float, x + i * 8, y + half + 40 + float);\r\n            ctx.stroke();\r\n          }\r\n\r\n          // 4. SHOULDER MANTLE (Purple-Gold Contrast)\r\n          ctx.strokeStyle = `rgba(220, 180, 255, ${0.7 * pulse})`;\r\n          ctx.lineWidth = 2.5;\r\n          ctx.beginPath();\r\n          ctx.moveTo(x - half - 15, y + float);\r\n          ctx.quadraticCurveTo(x, y - 22 + float, x + half + 15, y + float);\r\n          ctx.stroke();\r\n\r\n          // 5. THE CROWN OF COMMAND (Controlled shards)\r\n          ctx.fillStyle = `rgba(200, 100, 255, ${power})`;\r\n          for (let i = 0; i < 6; i++) {\r\n            const shardAng = (i / 6) * Math.PI - Math.PI;\r\n            const dist = 26 + Math.sin(time * 3 + i) * 6;\r\n            const sx = x + Math.cos(shardAng) * dist;\r\n            const sy = y - half - 22 + Math.sin(shardAng) * 12 + float;\r\n\r\n            ctx.save();\r\n            ctx.translate(sx, sy);\r\n            ctx.rotate(shardAng + Math.PI / 2);\r\n            ctx.beginPath();\r\n            ctx.moveTo(0, -8);\r\n            ctx.lineTo(4, 0);\r\n            ctx.lineTo(0, 8);\r\n            ctx.lineTo(-4, 0);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n\r\n            // Shard glow (Purple)\r\n            ctx.fillStyle = `rgba(220, 150, 255, ${0.4 * power})`;\r\n            ctx.beginPath();\r\n            ctx.arc(0, 0, 5, 0, Math.PI * 2);\r\n            ctx.fill();\r\n            ctx.restore();\r\n          }\r\n\r\n          // 6. FLOATING SOUL RUNES (Vibrant Purple)\r\n          ctx.font = 'bold 10px monospace';\r\n          ctx.textAlign = 'center';\r\n          ctx.fillStyle = `rgba(180, 100, 255, ${0.8 * pulse})`;\r\n          const runes = ['╬®', 'ÔÇá', 'Ôêå', '╬¿', '¤ÿ', 'Ð¬'];\r\n          for (let i = 0; i < runes.length; i++) {\r\n            const rAng = -magicSpin * 0.8 + (i * Math.PI * 2 / runes.length);\r\n            const rx = x + Math.cos(rAng) * (half + 45);\r\n            const ry = y + Math.sin(rAng) * 30 + float;\r\n            ctx.fillText(runes[i], rx, ry);\r\n\r\n            // Rune glow aura (Purple)\r\n            ctx.fillStyle = `rgba(150, 50, 255, ${0.15 * pulse})`;\r\n            ctx.beginPath();\r\n            ctx.arc(rx, ry - 3, 8, 0, Math.PI * 2);\r\n            ctx.fill();\r\n            ctx.fillStyle = `rgba(180, 100, 255, ${0.8 * pulse})`;\r\n          }\r\n\r\n          // 7. THE COLD GAZE (Eerie White-Purple)\r\n          ctx.fillStyle = '#ffffff';\r\n          ctx.fillRect(x - 7, y - half - 5 + float, 2, 10);\r\n          ctx.fillRect(x + 5, y - half - 5 + float, 2, 10);\r\n\r\n          // Eye glow (Purple)\r\n          const eyeG = ctx.createRadialGradient(x, y - half + float, 0, x, y - half + float, 20);\r\n          eyeG.addColorStop(0, `rgba(180, 50, 255, ${0.3 * pulse})`);\r\n          eyeG.addColorStop(1, 'rgba(0, 0, 0, 0)');\r\n          ctx.fillStyle = eyeG;\r\n          ctx.fillRect(x - 20, y - half - 15 + float, 40, 30);\r\n\r\n          // 8. SOUL ORBS (Orbital control)\r\n          for (let i = 0; i < 3; i++) {\r\n            const orbAng = magicSpin + (i * Math.PI * 2 / 3);\r\n            const orbitRadX = half + 55;\r\n            const orbitRadY = 20;\r\n            const ox = x + Math.cos(orbAng) * orbitRadX;\r\n            const oy = y + Math.sin(orbAng) * orbitRadY + float;\r\n\r\n            // Orb Core (Vibrant Purple)\r\n            const orbG = ctx.createRadialGradient(ox, oy, 0, ox, oy, 8);\r\n            orbG.addColorStop(0, '#ffffff');\r\n            orbG.addColorStop(0.3, `rgba(200, 50, 255, ${power})`);\r\n            orbG.addColorStop(1, 'rgba(80, 0, 120, 0)');\r\n            ctx.fillStyle = orbG;\r\n            ctx.beginPath();\r\n            ctx.arc(ox, oy, 7 + Math.sin(time * 10 + i) * 1.5, 0, Math.PI * 2);\r\n            ctx.fill();\r\n\r\n            // Energy Trail (Purple)\r\n            ctx.strokeStyle = `rgba(150, 50, 255, ${0.25 * power})`;\r\n            ctx.lineWidth = 1;\r\n            ctx.setLineDash([3, 3]);\r\n            ctx.beginPath();\r\n            ctx.moveTo(ox, oy);\r\n            ctx.lineTo(x, y + float);\r\n            ctx.stroke();\r\n            ctx.setLineDash([]);\r\n\r\n            // Purple shadow particles\r\n            if (Math.random() < 0.4) {\r\n              ctx.fillStyle = 'rgba(100, 0, 200, 0.7)';\r\n              ctx.fillRect(ox + (Math.random() - 0.5) * 8, oy + Math.random() * 12, 2, 2);\r\n            }\r\n          }\r\n\r\n          break;\r\n        }\r\n        case 4: {\r\n          // O FANTASMA ÔÇö SPECTRAL REAPER (Ceifador das Almas)\r\n          const gFloat = Math.sin(time * 6 + e.x) * 4;\r\n          const deathPulse = Math.sin(time * 4) * 0.3 + 0.7;\r\n          const reap = Math.sin(time * 3) * 0.4;\r\n\r\n          ctx.globalAlpha = 0.95;\r\n\r\n          // Death realm aura (portal to afterlife)\r\n          for (let layer = 0; layer < 5; layer++) {\r\n            const realmSize = half + 24 + layer * 6;\r\n            const realmAlpha = (0.18 - layer * 0.03) * deathPulse;\r\n            const realmGrad = ctx.createRadialGradient(x, y + gFloat, half, x, y + gFloat, realmSize);\r\n            realmGrad.addColorStop(0, `rgba(0, 180, 150, ${realmAlpha})`);\r\n            realmGrad.addColorStop(0.6, `rgba(0, 120, 100, ${realmAlpha * 0.6})`);\r\n            realmGrad.addColorStop(1, 'rgba(0, 80, 70, 0)');\r\n            ctx.fillStyle = realmGrad;\r\n            ctx.fillRect(x - realmSize, y - realmSize + gFloat, realmSize * 2, realmSize * 2);\r\n          }\r\n\r\n          // Soul vortex (spirits being reaped)\r\n          for (let i = 0; i < 10; i++) {\r\n            const soulAngle = time * 3 + (i * Math.PI * 2 / 10);\r\n            const soulRadius = half + 12 + Math.sin(time * 5 + i) * 3;\r\n            const sx = x + Math.cos(soulAngle) * soulRadius;\r\n            const sy = y + Math.sin(soulAngle) * (soulRadius * 0.5) + gFloat;\r\n            ctx.fillStyle = `rgba(100, 255, 230, ${0.4 * deathPulse})`;\r\n            ctx.fillRect(sx - 1, sy - 1, 2, 2);\r\n          }\r\n\r\n          // Flowing spectral robes (death shroud)\r\n          ctx.fillStyle = e.flashTime > 0 ? 'rgba(255, 255, 255, 0.8)' : 'rgba(0, 170, 150, 0.7)';\r\n          ctx.beginPath();\r\n          ctx.moveTo(x - half - 3, y - half + gFloat);\r\n          ctx.lineTo(x + half + 3, y - half + gFloat);\r\n          ctx.quadraticCurveTo(x + half + 5, y + gFloat, x + half + 4, y + half + 7 + gFloat);\r\n          ctx.lineTo(x - half - 4, y + half + 7 + gFloat);\r\n          ctx.quadraticCurveTo(x - half - 5, y + gFloat, x - half - 3, y - half + gFloat);\r\n          ctx.fill();\r\n\r\n          // Robe ethereal wisps (flowing tendrils)\r\n          ctx.strokeStyle = e.flashTime > 0 ? 'rgba(255, 255, 255, 0.6)' : 'rgba(0, 200, 180, 0.5)';\r\n          ctx.lineWidth = 2;\r\n          for (let i = 0; i < 6; i++) {\r\n            const wx = x - 9 + i * 3.5 + Math.sin(time * 5 + i * 0.8) * 4;\r\n            const tendrilLength = 10 + i * 1.5;\r\n            ctx.beginPath();\r\n            ctx.moveTo(wx, y + half + gFloat);\r\n            ctx.quadraticCurveTo(\r\n              wx + Math.sin(time * 6 + i) * 3, y + half + gFloat + tendrilLength / 2,\r\n              wx + Math.sin(time * 4 + i) * 5, y + half + gFloat + tendrilLength\r\n            );\r\n            ctx.stroke();\r\n          }\r\n\r\n          // Main spectral body (translucent)\r\n          const bodyGrad = ctx.createRadialGradient(x, y + gFloat, 0, x, y + gFloat, half + 1);\r\n          bodyGrad.addColorStop(0, e.flashTime > 0 ? C.COLORS.white : 'rgba(120, 255, 240, 0.8)');\r\n          bodyGrad.addColorStop(0.6, e.flashTime > 0 ? C.COLORS.white : 'rgba(0, 200, 180, 0.6)');\r\n          bodyGrad.addColorStop(1, 'rgba(0, 150, 140, 0.3)');\r\n          ctx.fillStyle = bodyGrad;\r\n          ctx.beginPath();\r\n          ctx.arc(x, y + gFloat, half + 1, 0, Math.PI * 2);\r\n          ctx.fill();\r\n\r\n          // Hooded skull (grim reaper)\r\n          ctx.fillStyle = e.flashTime > 0 ? C.COLORS.white : 'rgba(0, 100, 90, 0.9)';\r\n          ctx.beginPath();\r\n          ctx.arc(x, y - half + 2 + gFloat, half + 1, Math.PI * 0.9, Math.PI * 2.1);\r\n          ctx.fill();\r\n\r\n          // Deep void within hood\r\n          ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';\r\n          ctx.fillRect(x - half + 2, y - half + 2 + gFloat, s - 4, 6);\r\n\r\n          // Haunting cyan eyes (death stare)\r\n          ctx.fillStyle = `rgba(100, 255, 255, ${deathPulse})`;\r\n          ctx.fillRect(x - 5, y - half + 4 + gFloat, 3, 3);\r\n          ctx.fillRect(x + 3, y - half + 4 + gFloat, 3, 3);\r\n\r\n          ctx.fillStyle = `rgba(0, 255, 220, ${deathPulse * 0.7})`;\r\n          ctx.fillRect(x - 7, y - half + 3 + gFloat, 7, 5);\r\n          ctx.fillRect(x + 1, y - half + 3 + gFloat, 7, 5);\r\n\r\n          // MASSIVE SCYTHE (signature weapon)\r\n          const scytheHandle = s + 18;\r\n          const scytheX = x - half - 8;\r\n\r\n          // Scythe handle (long staff)\r\n          ctx.fillStyle = '#0a2020';\r\n          ctx.fillRect(scytheX, y - half - 8 + gFloat + reap, 3, scytheHandle);\r\n\r\n          // Handle decorations\r\n          ctx.fillStyle = '#1a4040';\r\n          for (let i = 0; i < 6; i++) {\r\n            ctx.fillRect(scytheX - 1, y - half - 6 + i * 5 + gFloat, 5, 2);\r\n          }\r\n\r\n          // Scythe blade (curved death blade)\r\n          const bladeY = y - half - 10 + gFloat + reap;\r\n          ctx.fillStyle = `rgba(50, 200, 180, ${deathPulse * 0.9})`;\r\n\r\n          // Outer blade glow\r\n          ctx.beginPath();\r\n          ctx.moveTo(scytheX + 1.5, bladeY);\r\n          ctx.quadraticCurveTo(scytheX + 15, bladeY - 8, scytheX + 20, bladeY - 6);\r\n          ctx.quadraticCurveTo(scytheX + 16, bladeY - 3, scytheX + 1.5, bladeY + 2);\r\n          ctx.fill();\r\n\r\n          // Inner blade (sharper)\r\n          ctx.fillStyle = `rgba(150, 255, 240, ${deathPulse})`;\r\n          ctx.beginPath();\r\n          ctx.moveTo(scytheX + 1.5, bladeY);\r\n          ctx.quadraticCurveTo(scytheX + 14, bladeY - 7, scytheX + 18, bladeY - 5);\r\n          ctx.quadraticCurveTo(scytheX + 15, bladeY - 2, scytheX + 1.5, bladeY + 1);\r\n          ctx.fill();\r\n\r\n          // Blade edge highlight (deadly)\r\n          ctx.strokeStyle = `rgba(200, 255, 255, ${deathPulse})`;\r\n          ctx.lineWidth = 1;\r\n          ctx.beginPath();\r\n          ctx.moveTo(scytheX + 18, bladeY - 5);\r\n          ctx.lineTo(scytheX + 19, bladeY - 4);\r\n          ctx.stroke();\r\n\r\n          // Soul particles around scythe\r\n          for (let i = 0; i < 5; i++) {\r\n            const px = scytheX + 10 + (Math.random() - 0.5) * 12;\r\n            const py = bladeY + (Math.random() - 0.5) * 8;\r\n            ctx.fillStyle = `rgba(100, 255, 230, ${0.5 + Math.random() * 0.5})`;\r\n            ctx.fillRect(px, py, 1.5, 1.5);\r\n          }\r\n\r\n          // Phase rings (dimensional presence)\r\n          for (let i = 0; i < 3; i++) {\r\n            ctx.strokeStyle = `rgba(0, 255, 220, ${(0.25 - i * 0.06) * deathPulse})`;\r\n            ctx.lineWidth = 1;\r\n            ctx.beginPath();\r\n            ctx.arc(x, y + gFloat, half + 10 + i * 6 + Math.sin(time * 4 - i) * 3, 0, Math.PI * 2);\r\n            ctx.stroke();\r\n          }\r\n\r\n          ctx.globalAlpha = 1;\r\n          break;\r\n        }\r\n        case 5: {\r\n          // ÔòÉÔòÉÔòÉ VOID-IRON DREADNOUGHT - O Destruidor de Mundos ÔòÉÔòÉÔòÉ\r\n          const titanPower = Math.sin(time * 3.5) * 0.3 + 0.7;\r\n          const charge = e.aiState === 'charge';\r\n          const slam = Math.sin(time * 10) * (charge ? 2 : 0.5);\r\n          const corePulse = Math.sin(time * 8) * 0.3 + 0.7;\r\n\r\n          // Industrial War Aura\r\n          for (let layer = 0; layer < 5; layer++) {\r\n            const auraSize = half + 25 + layer * 8;\r\n            const auraAlpha = (0.15 - layer * 0.03) * titanPower;\r\n            const ironGrad = ctx.createRadialGradient(x, y + breathe, 0, x, y + breathe, auraSize);\r\n            ironGrad.addColorStop(0, `rgba(100, 50, 0, ${auraAlpha})`);\r\n            ironGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');\r\n            ctx.fillStyle = ironGrad;\r\n            ctx.fillRect(x - auraSize, y - auraSize + breathe, auraSize * 2, auraSize * 2);\r\n          }\r\n\r\n          // EXHAUST PIPES (Vapor/Sparks)\r\n          ctx.fillStyle = '#222222';\r\n          // Left Pipe\r\n          ctx.fillRect(x - half - 10, y - half - 5 + breathe, 6, 15);\r\n          // Right Pipe\r\n          ctx.fillRect(x + half + 4, y - half - 5 + breathe, 6, 15);\r\n\r\n          // Sparks from pipes\r\n          for (let i = 0; i < 6; i++) {\r\n            const sx = x - half - 7 + (Math.random() - 0.5) * 4;\r\n            const sy = y - half - 10 + breathe - (time * 20 + i * 10) % 30;\r\n            ctx.fillStyle = `rgba(255, 100, 0, ${Math.random()})`;\r\n            ctx.fillRect(sx, sy, 2, 2);\r\n          }\r\n\r\n          // ASYMMETRICAL TITAN SILHOUETTE\r\n          const plateColor = e.flashTime > 0 ? C.COLORS.white : '#333333';\r\n          const jointColor = '#1a1a1a';\r\n          ctx.fillStyle = plateColor;\r\n\r\n          // Waist (Thin center)\r\n          ctx.fillRect(x - 6, y + 2 + breathe, 12, 10);\r\n\r\n          // Massive Torso / Chest Plate (Hexagonal)\r\n          ctx.beginPath();\r\n          ctx.moveTo(x - 12, y - half + 5 + breathe);\r\n          ctx.lineTo(x + 12, y - half + 5 + breathe);\r\n          ctx.lineTo(x + 18, y + 2 + breathe);\r\n          ctx.lineTo(x - 18, y + 2 + breathe);\r\n          ctx.closePath();\r\n          ctx.fill();\r\n\r\n          // HUGE PAULDRONS (Shoulders)\r\n          ctx.fillStyle = e.flashTime > 0 ? C.COLORS.white : '#444444';\r\n          // Right Pauldron (The Heavy Arm)\r\n          ctx.beginPath();\r\n          ctx.arc(x + 18, y - half + 5 + breathe, 12, 0, Math.PI * 2);\r\n          ctx.fill();\r\n          // Left Pauldron\r\n          ctx.beginPath();\r\n          ctx.arc(x - 18, y - half + 5 + breathe, 10, 0, Math.PI * 2);\r\n          ctx.fill();\r\n\r\n          // pauldrons trim\r\n          ctx.strokeStyle = '#666666';\r\n          ctx.lineWidth = 2;\r\n          ctx.stroke();\r\n\r\n          // THE NUCLEAR FUSION CORE\r\n          const coreGlow = ctx.createRadialGradient(x, y - 5 + breathe, 0, x, y - 5 + breathe, 10);\r\n          coreGlow.addColorStop(0, `rgba(0, 200, 255, ${corePulse})`);\r\n          coreGlow.addColorStop(0.5, `rgba(0, 100, 255, 0.5)`);\r\n          coreGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');\r\n          ctx.fillStyle = coreGlow;\r\n          ctx.beginPath();\r\n          ctx.arc(x, y - 5 + breathe, 8, 0, Math.PI * 2);\r\n          ctx.fill();\r\n          // Core center\r\n          ctx.fillStyle = '#ffffff';\r\n          ctx.beginPath();\r\n          ctx.arc(x, y - 5 + breathe, 3 * corePulse, 0, Math.PI * 2);\r\n          ctx.fill();\r\n\r\n          // Mechanical Arms\r\n          ctx.fillStyle = jointColor;\r\n          // Right Crushing Arm\r\n          ctx.fillRect(x + 22, y - half + 10 + breathe + slam, 8, 25);\r\n          ctx.fillStyle = plateColor;\r\n          ctx.fillRect(x + 20, y - half + 30 + breathe + slam, 12, 10); // Massive Fist\r\n\r\n          // Left Support Arm\r\n          ctx.fillStyle = jointColor;\r\n          ctx.fillRect(x - 28, y - half + 10 + breathe, 8, 20);\r\n          ctx.fillStyle = plateColor;\r\n          ctx.beginPath(); // Shield Arm\r\n          ctx.moveTo(x - 32, y - half + 20 + breathe);\r\n          ctx.lineTo(x - 18, y - half + 20 + breathe);\r\n          ctx.lineTo(x - 20, y - half + 40 + breathe);\r\n          ctx.lineTo(x - 30, y - half + 40 + breathe);\r\n          ctx.closePath();\r\n          ctx.fill();\r\n\r\n          // HEAD - Armored visor\r\n          ctx.fillStyle = '#222222';\r\n          ctx.beginPath();\r\n          ctx.ellipse(x, y - half - 5 + breathe + slam, 7, 5, 0, 0, Math.PI * 2);\r\n          ctx.fill();\r\n          // Visor Light\r\n          ctx.fillStyle = charge ? '#ff0000' : '#00ccff';\r\n          ctx.fillRect(x - 4, y - half - 6 + breathe + slam, 8, 2);\r\n\r\n          // Leg Stance (Mechanical legs)\r\n          ctx.fillStyle = jointColor;\r\n          ctx.fillRect(x - 12, y + 12 + breathe, 6, 12);\r\n          ctx.fillRect(x + 6, y + 12 + breathe, 6, 12);\r\n          ctx.fillStyle = plateColor;\r\n          ctx.fillRect(x - 15, y + 20 + breathe, 8, 5);\r\n          ctx.fillRect(x + 7, y + 20 + breathe, 8, 5);\r\n\r\n          break;\r\n        }\r\n        case 6: {\r\n          // ÔòÉÔòÉÔòÉ THE VOID SINGULARITY - O Pesadelo Final ÔòÉÔòÉÔòÉ\r\n          const madness = Math.sin(time * 4) * 0.3 + 0.7;\r\n          const shiftX = Math.sin(time * 2) * 5;\r\n          const shiftY = Math.cos(time * 3) * 5;\r\n\r\n          // Event Horizon Aura (Deep Space Distortion)\r\n          for (let layer = 0; layer < 6; layer++) {\r\n            const auraSize = half + 30 + layer * 10;\r\n            const auraAlpha = (0.25 - layer * 0.04) * madness;\r\n            const voidGrad = ctx.createRadialGradient(x + shiftX, y + shiftY + breathe, 0, x + shiftX, y + shiftY + breathe, auraSize);\r\n            voidGrad.addColorStop(0, `rgba(20, 0, 40, ${auraAlpha})`);\r\n            voidGrad.addColorStop(0.7, `rgba(10, 0, 20, ${auraAlpha * 0.5})`);\r\n            voidGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');\r\n            ctx.fillStyle = voidGrad;\r\n            ctx.beginPath();\r\n            ctx.arc(x + shiftX, y + shiftY + breathe, auraSize, 0, Math.PI * 2);\r\n            ctx.fill();\r\n          }\r\n\r\n          // REALITY SHARDS (Floating crystalline fragments)\r\n          for (let i = 0; i < 10; i++) {\r\n            const orbitAngle = time * 1.5 + i * (Math.PI * 2 / 10);\r\n            const orbitRad = s + 10 + Math.sin(time * 3 + i) * 10;\r\n            const sx = x + Math.cos(orbitAngle) * orbitRad;\r\n            const sy = y + Math.sin(orbitAngle) * orbitRad * 0.5 + breathe;\r\n\r\n            ctx.fillStyle = i % 2 === 0 ? 'rgba(100, 0, 255, 0.6)' : 'rgba(255, 0, 100, 0.6)';\r\n            ctx.beginPath();\r\n            ctx.moveTo(sx, sy - 5);\r\n            ctx.lineTo(sx + 3, sy);\r\n            ctx.lineTo(sx, sy + 5);\r\n            ctx.lineTo(sx - 3, sy);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n          }\r\n\r\n          // WRITHING DARK TENTACLES (More organic limbs)\r\n          for (let i = 0; i < 12; i++) {\r\n            const angle = (i / 12) * Math.PI * 2 + time;\r\n            const length = s + 15 + Math.sin(time * 4 + i) * 10;\r\n            const controlX = x + Math.cos(angle + 0.5) * (length / 2);\r\n            const controlY = y + Math.sin(angle + 0.5) * (length / 2) + breathe;\r\n            const endX = x + Math.cos(angle) * length;\r\n            const endY = y + Math.sin(angle) * length + breathe;\r\n\r\n            ctx.strokeStyle = `rgba(40, 0, 60, ${0.8 * madness})`;\r\n            ctx.lineWidth = 4 - (i % 3);\r\n            ctx.beginPath();\r\n            ctx.moveTo(x + shiftX, y + shiftY + breathe);\r\n            ctx.quadraticCurveTo(controlX, controlY, endX, endY);\r\n            ctx.stroke();\r\n\r\n            // Scurrying eyes on tentacles\r\n            if (i % 3 === 0) {\r\n              ctx.fillStyle = `rgba(255, 0, 50, ${madness})`;\r\n              ctx.beginPath();\r\n              ctx.arc(controlX, controlY, 2, 0, Math.PI * 2);\r\n              ctx.fill();\r\n            }\r\n          }\r\n\r\n          // THE SINGULARITY CORE (The Black Hole)\r\n          const coreSize = half + 5;\r\n          ctx.fillStyle = '#000000';\r\n          ctx.beginPath();\r\n          ctx.arc(x + shiftX, y + shiftY + breathe, coreSize, 0, Math.PI * 2);\r\n          ctx.fill();\r\n\r\n          // White Light Ring (Accretion Disk)\r\n          ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 * madness})`;\r\n          ctx.lineWidth = 1.5;\r\n          ctx.beginPath();\r\n          ctx.arc(x + shiftX, y + shiftY + breathe, coreSize + 2, time * 2, time * 2 + Math.PI * 1.5);\r\n          ctx.stroke();\r\n\r\n          // ÔòÉÔòÉÔòÉ MANY EYES OF THE VOID ÔòÉÔòÉÔòÉ\r\n          for (let i = 0; i < 6; i++) {\r\n            const eyeAng = time * 0.8 + i * (Math.PI / 3);\r\n            const eyeDist = coreSize * 0.6;\r\n            const ex = x + shiftX + Math.cos(eyeAng) * eyeDist;\r\n            const ey = y + shiftY + Math.sin(eyeAng) * eyeDist + breathe;\r\n\r\n            ctx.fillStyle = '#ffffff';\r\n            ctx.beginPath();\r\n            ctx.ellipse(ex, ey, 3, 1.5, eyeAng, 0, Math.PI * 2);\r\n            ctx.fill();\r\n\r\n            ctx.fillStyle = '#ff0000';\r\n            ctx.beginPath();\r\n            ctx.arc(ex, ey, 1, 0, Math.PI * 2);\r\n            ctx.fill();\r\n          }\r\n\r\n          // Final Void Resonance\r\n          for (let i = 0; i < 3; i++) {\r\n            const rSize = s + i * 15 + Math.sin(time * 5) * 5;\r\n            ctx.strokeStyle = `rgba(150, 0, 255, ${0.15 - i * 0.05})`;\r\n            ctx.lineWidth = 1;\r\n            ctx.beginPath();\r\n            ctx.arc(x + shiftX, y + shiftY + breathe, rSize, 0, Math.PI * 2);\r\n            ctx.stroke();\r\n          }\r\n\r\n          break;\r\n        }\r\n        default: {\r\n          // Floor 1: SOMBRA FAMINTA ÔÇö DEMONIC COLOSSUS\r\n          // A powerful beastial silhouette that breaks the boxy look with curves and asymmetry\r\n          const shadowPulse = Math.sin(time * 3) * 0.3 + 0.7;\r\n          const roar = Math.sin(time * 8) * (e.flashTime > 0 ? 2 : 0.8);\r\n          const beastFloat = breathe + roar * 0.5;\r\n\r\n          // 1. VOID AZURE AURA\r\n          for (let layer = 0; layer < 6; layer++) {\r\n            const auraSize = half + 30 + layer * 10;\r\n            const auraAlpha = (0.24 - layer * 0.04) * shadowPulse;\r\n            const darkAura = ctx.createRadialGradient(x, y + beastFloat, half, x, y + beastFloat, auraSize);\r\n            darkAura.addColorStop(0, `rgba(20, 60, 180, ${auraAlpha})`);\r\n            darkAura.addColorStop(0.6, `rgba(10, 20, 80, ${auraAlpha * 0.5})`);\r\n            darkAura.addColorStop(1, 'rgba(0, 0, 0, 0)');\r\n            ctx.fillStyle = darkAura;\r\n            ctx.beginPath();\r\n            ctx.arc(x, y + beastFloat, auraSize, 0, Math.PI * 2);\r\n            ctx.fill();\r\n          }\r\n\r\n          // 2. SHADOW TENDRILS (Breaking the bottom flat edge)\r\n          ctx.strokeStyle = '#00081a';\r\n          ctx.lineWidth = 3;\r\n          for (let i = 0; i < 8; i++) {\r\n            const tx = x - half + (i * s / 7);\r\n            const ty = y + half + beastFloat;\r\n            const tLen = 12 + Math.sin(time * 5 + i) * 8;\r\n            ctx.beginPath();\r\n            ctx.moveTo(tx, ty - 5);\r\n            ctx.quadraticCurveTo(tx + Math.sin(time * 4 + i) * 10, ty + tLen / 2, tx, ty + tLen);\r\n            ctx.stroke();\r\n          }\r\n\r\n          // 3. HUNTER'S HUNCHED BODY (Organic & Powerful - Deep Blue)\r\n          const bodyColor = e.flashTime > 0 ? C.COLORS.white : '#00051a';\r\n          ctx.fillStyle = bodyColor;\r\n\r\n          ctx.beginPath();\r\n          // Drawing a more beastial, hunched silhouette\r\n          ctx.moveTo(x - half - 8, y + half + 5 + beastFloat); // Bottom left\r\n          ctx.quadraticCurveTo(x - half - 15, y, x - half, y - half - 5 + beastFloat); // Left side to shoulder\r\n          ctx.quadraticCurveTo(x, y - half - 20 + beastFloat, x + half + 5, y - half + beastFloat); // Hunch to right shoulder\r\n          ctx.quadraticCurveTo(x + half + 12, y + half, x + half + 2, y + half + 5 + beastFloat); // Right side to bottom\r\n          ctx.bezierCurveTo(x, y + half + 15 + beastFloat, x - half, y + half + 10 + beastFloat, x - half - 8, y + half + 5 + beastFloat);\r\n          ctx.fill();\r\n\r\n          // 4. SCARRED ARMOR PLATES (Asymmetric Blue Armor)\r\n          ctx.fillStyle = e.flashTime > 0 ? C.COLORS.white : '#081a33';\r\n\r\n          // Main Chest Plate (Jagged)\r\n          ctx.beginPath();\r\n          ctx.moveTo(x - 12, y - 5 + beastFloat);\r\n          ctx.lineTo(x + 8, y - 8 + beastFloat);\r\n          ctx.lineTo(x + 15, y + 10 + beastFloat);\r\n          ctx.lineTo(x - 6, y + 15 + beastFloat);\r\n          ctx.closePath();\r\n          ctx.fill();\r\n\r\n          // Armor Detail (Azure Core in chest)\r\n          const coreG = ctx.createRadialGradient(x + 2, y + 5 + beastFloat, 0, x + 2, y + 5 + beastFloat, 8);\r\n          coreG.addColorStop(0, `rgba(0, 150, 255, ${shadowPulse})`);\r\n          coreG.addColorStop(1, 'rgba(0, 20, 80, 0)');\r\n          ctx.fillStyle = coreG;\r\n          ctx.beginPath();\r\n          ctx.arc(x + 2, y + 5 + beastFloat, 6, 0, Math.PI * 2);\r\n          ctx.fill();\r\n\r\n          // 5. ASYMMETRIC HORNS (Dark Metallic Blue)\r\n          ctx.fillStyle = e.flashTime > 0 ? C.COLORS.white : '#1a2433';\r\n\r\n          // Left Horn (Large, curved upwards)\r\n          ctx.beginPath();\r\n          ctx.moveTo(x - 10, y - half - 10 + beastFloat);\r\n          ctx.quadraticCurveTo(x - 25, y - half - 25 + beastFloat, x - 15, y - half - 45 + beastFloat);\r\n          ctx.quadraticCurveTo(x - 5, y - half - 25 + beastFloat, x - 2, y - half - 12 + beastFloat);\r\n          ctx.fill();\r\n\r\n          // Right Horn (Broken, jagged stub)\r\n          ctx.beginPath();\r\n          ctx.moveTo(x + 8, y - half - 8 + beastFloat);\r\n          ctx.lineTo(x + 20, y - half - 15 + beastFloat);\r\n          ctx.lineTo(x + 15, y - half - 5 + beastFloat);\r\n          ctx.lineTo(x + 10, y - half + 2 + beastFloat);\r\n          ctx.closePath();\r\n          ctx.fill();\r\n\r\n          // 6. THE COLD GAZE (Eerie Light Blue eyes)\r\n          const eyeH = 2 + Math.sin(time * 12) * 1;\r\n          ctx.fillStyle = '#00ccff';\r\n          // Large main eyes\r\n          ctx.beginPath();\r\n          ctx.ellipse(x - 8, y - half + 5 + beastFloat, 5, eyeH, 0.2, 0, Math.PI * 2);\r\n          ctx.fill();\r\n          ctx.beginPath();\r\n          ctx.ellipse(x + 6, y - half + 4 + beastFloat, 4, eyeH, -0.1, 0, Math.PI * 2);\r\n          ctx.fill();\r\n\r\n          // Pupils (White/Cyan)\r\n          ctx.fillStyle = '#ffffff';\r\n          ctx.fillRect(x - 9, y - half + 4 + beastFloat, 2, eyeH);\r\n          ctx.fillRect(x + 5, y - half + 3 + beastFloat, 1.5, eyeH);\r\n\r\n          // 7. BESTIAL JAW (Darkened blue teeth)\r\n          ctx.fillStyle = '#00081a';\r\n          ctx.beginPath();\r\n          ctx.moveTo(x - 12, y + half + beastFloat + roar * 2);\r\n          ctx.lineTo(x + 10, y + half + 2 + beastFloat + roar * 2);\r\n          ctx.lineTo(x, y + half + 12 + beastFloat + roar * 2);\r\n          ctx.closePath();\r\n          ctx.fill();\r\n\r\n          // Teeth glint\r\n          ctx.fillStyle = '#ccdeff';\r\n          for (let i = 0; i < 3; i++) {\r\n            ctx.fillRect(x - 6 + i * 5, y + half + 2 + beastFloat + roar * 2, 1.5, 3);\r\n          }\r\n\r\n          // 8. BLUE MIST & SPARKS\r\n          if (Math.random() < 0.8) {\r\n            const ex = x + (Math.random() - 0.5) * s * 1.5;\r\n            const ey = y + (Math.random() - 0.5) * s + beastFloat;\r\n            ctx.fillStyle = `rgba(100, 200, 255, ${0.4})`;\r\n            ctx.fillRect(ex, ey, 2, 2);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Reset alpha for wraith\r\n  if (e.type === 'wraith') ctx.globalAlpha = 1;\r\n\r\n  // HP bar\r\n  if (e.hp < e.maxHp) {\r\n    const barW_hp = Math.max(s + 4, 12);\r\n    const barH_hp = 2;\r\n    const bx = x - barW_hp / 2;\r\n    const by = y - half - 7;\r\n    ctx.fillStyle = C.COLORS.hpBg;\r\n    ctx.fillRect(bx, by, barW_hp, barH_hp);\r\n    ctx.fillStyle = e.hp / e.maxHp > 0.3 ? C.COLORS.hpFill : '#cc2200';\r\n    ctx.fillRect(bx, by, barW_hp * (e.hp / e.maxHp), barH_hp);\r\n  }\r\n}\r\n\r\nexport function renderEssenceCores(ctx: CanvasRenderingContext2D, cores: EssenceCore[], time: number) {\r\n  for (const core of cores) {\r\n    const isBoss = core.type === 'boss';\r\n    const s = (isBoss ? 8 : 4) + Math.sin(time * 10) * 1;\r\n\r\n    ctx.save();\r\n    // Glow\r\n    const gradient = ctx.createRadialGradient(core.x, core.y, 0, core.x, core.y, s * 2.5);\r\n    gradient.addColorStop(0, 'rgba(106, 13, 173, 0.4)');\r\n    gradient.addColorStop(1, 'rgba(106, 13, 173, 0)');\r\n    ctx.fillStyle = gradient;\r\n    ctx.beginPath();\r\n    ctx.arc(core.x, core.y, s * 2.5, 0, Math.PI * 2);\r\n    ctx.fill();\r\n\r\n    // Pulse Core\r\n    const pulse = 0.8 + Math.sin(time * 8) * 0.2;\r\n    ctx.globalAlpha = pulse;\r\n    ctx.fillStyle = '#ac4dff';\r\n    ctx.beginPath();\r\n    ctx.arc(core.x, core.y, s * 0.5, 0, Math.PI * 2);\r\n    ctx.fill();\r\n\r\n    // Middle spark\r\n    ctx.fillStyle = '#ffffff';\r\n    ctx.beginPath();\r\n    ctx.arc(core.x, core.y, s * 0.15, 0, Math.PI * 2);\r\n    ctx.fill();\r\n\r\n    ctx.restore();\r\n  }\r\n}\r\n\r\nexport function renderAlchemist(ctx: CanvasRenderingContext2D, x: number, y: number, time: number) {\r\n  // --- BASE SHADOW ---\r\n  ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';\r\n  ctx.beginPath();\r\n  ctx.ellipse(x, y + 8, 10, 4, 0, 0, Math.PI * 2);\r\n  ctx.fill();\r\n\r\n  // Floating bob effect\r\n  const bob = Math.sin(time * 1.5) * 2;\r\n  const ay = y + bob;\r\n\r\n  // --- ROBE & BODY (Teal/Deep Emerald) ---\r\n  // Outer Robe/Cloak\r\n  ctx.fillStyle = '#1a3c34';\r\n  ctx.beginPath();\r\n  ctx.moveTo(x - 8, ay - 6);\r\n  ctx.lineTo(x + 8, ay - 6);\r\n  ctx.lineTo(x + 12, ay + 10);\r\n  ctx.lineTo(x - 12, ay + 10);\r\n  ctx.fill();\r\n\r\n  // Alchemy Apron (Leather/Brown)\r\n  ctx.fillStyle = '#4a3728';\r\n  ctx.fillRect(x - 5, ay - 2, 10, 12);\r\n\r\n  // --- BELT & UTILITIES ---\r\n  ctx.fillStyle = '#2a1a0a';\r\n  ctx.fillRect(x - 9, ay + 3, 18, 2); // Belt\r\n\r\n  // Small hanging vials on the belt\r\n  const vialColors = ['#ff5555', '#55ff88', '#5588ff'];\r\n  for (let i = 0; i < 3; i++) {\r\n    const vx = x - 6 + i * 6;\r\n    const vy = ay + 5 + Math.sin(time * 3 + i) * 0.5;\r\n    ctx.fillStyle = '#111111'; // Cork\r\n    ctx.fillRect(vx - 1, vy, 2, 1);\r\n    ctx.fillStyle = vialColors[i];\r\n    ctx.globalAlpha = 0.7 + Math.sin(time * 4 + i) * 0.3;\r\n    ctx.fillRect(vx - 2, vy + 1, 4, 4);\r\n    ctx.globalAlpha = 1;\r\n  }\r\n\r\n  // Large side bag\r\n  ctx.fillStyle = '#5c4033';\r\n  ctx.beginPath();\r\n  ctx.roundRect(x + 6, ay + 4, 6, 5, 2);\r\n  ctx.fill();\r\n\r\n  // --- ARMS & POTION ANIMATION ---\r\n  // She's hunched, holding a flask with both hands\r\n  const handX = x + Math.cos(time * 2) * 2;\r\n  const handY = ay + 2 + Math.sin(time * 2) * 1;\r\n\r\n  // Flask (Glass Texture)\r\n  const flaskSize = 5;\r\n  const grad = ctx.createRadialGradient(handX, handY, 0, handX, handY, flaskSize + 5);\r\n  grad.addColorStop(0, 'rgba(100, 255, 100, 0.4)');\r\n  grad.addColorStop(1, 'rgba(100, 255, 100, 0)');\r\n  ctx.fillStyle = grad;\r\n  ctx.beginPath();\r\n  ctx.arc(handX, handY, flaskSize + 5, 0, Math.PI * 2);\r\n  ctx.fill();\r\n\r\n  ctx.fillStyle = '#aaffaa'; // Liquid\r\n  ctx.beginPath();\r\n  ctx.arc(handX, handY, flaskSize, 0, Math.PI * 2);\r\n  ctx.fill();\r\n\r\n  // Flask highlights\r\n  ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';\r\n  ctx.lineWidth = 1;\r\n  ctx.beginPath();\r\n  ctx.arc(handX, handY, flaskSize, -1, 1);\r\n  ctx.stroke();\r\n\r\n  // Rising noxious steam\r\n  if (Math.random() < 0.2) {\r\n    const steamX = handX + (Math.random() - 0.5) * 8;\r\n    const steamY = handY - 5 - Math.random() * 10;\r\n    ctx.fillStyle = `rgba(150, 255, 150, ${0.2 + Math.random() * 0.3})`;\r\n    ctx.beginPath();\r\n    ctx.arc(steamX, steamY, 1 + Math.random() * 2, 0, Math.PI * 2);\r\n    ctx.fill();\r\n  }\r\n\r\n  // --- HEAD & DISTINCT HAT (The Silhueta) ---\r\n  // Neck/Hunch\r\n  ctx.fillStyle = '#2d4d44';\r\n  ctx.beginPath();\r\n  ctx.arc(x, ay - 8, 4, 0, Math.PI * 2);\r\n  ctx.fill();\r\n\r\n  // Wide Alchemist Hat (Asymmetric pointed look)\r\n  ctx.fillStyle = '#0a1a15';\r\n  // Brim\r\n  ctx.beginPath();\r\n  ctx.ellipse(x, ay - 11, 14, 4, 0.1, 0, Math.PI * 2);\r\n  ctx.fill();\r\n  // Pointy top (relaxed/droopy)\r\n  ctx.beginPath();\r\n  ctx.moveTo(x - 8, ay - 12);\r\n  ctx.lineTo(x + 8, ay - 12);\r\n  ctx.quadraticCurveTo(x + 2, ay - 18, x - 12, ay - 24); // Drooping point to the left\r\n  ctx.lineTo(x - 2, ay - 15);\r\n  ctx.fill();\r\n\r\n  // Eyes (Glowing Amber/Cyan)\r\n  const eyePulse = Math.sin(time * 4) * 0.2 + 0.8;\r\n  ctx.fillStyle = `rgba(255, 170, 0, ${eyePulse})`;\r\n  ctx.fillRect(x - 4, ay - 10, 2, 1);\r\n  ctx.fillRect(x + 2, ay - 10, 2, 1);\r\n\r\n  // --- AMBIENT EFFECT ---\r\n  // Subtle glowing particles around her\r\n  for (let i = 0; i < 3; i++) {\r\n    const ang = time * 0.5 + i * (Math.PI * 2 / 3);\r\n    const px = x + Math.cos(ang) * 18;\r\n    const py = ay + Math.sin(ang * 2) * 10;\r\n    ctx.fillStyle = `rgba(150, 255, 220, ${0.15 * eyePulse})`;\r\n    ctx.beginPath();\r\n    ctx.arc(px, py, 1, 0, Math.PI * 2);\r\n    ctx.fill();\r\n  }\r\n}\r\n\r\n/**\r\n * ProjectileOrigin: Identifies the free hand socket for channeled attacks\r\n */\r\nexport const ProjectileOrigin = {\r\n  getHandSocket(p: PlayerState, time: number): { x: number, y: number } {\r\n    const frameOrFrames = getSpriteFrameForFacing(p);\r\n    const moves = p.isMoving || p.isDashing || p.meleeAttacking;\r\n    const currentFrame = Array.isArray(frameOrFrames)\r\n      ? frameOrFrames[Math.floor(time * (moves ? 10 : 1.2)) % frameOrFrames.length]\r\n      : frameOrFrames;\r\n\r\n    const isBackFrame = currentFrame.src.includes('costa');\r\n\r\n    // Auto-identify free hand: \r\n    // Sword/Staff uses Right Hand for weapon, so Left Hand is free.\r\n    // Daggers uses both, we pick Left Hand as the ritual/cast hand.\r\n    const useLeftHand = true;\r\n\r\n    const socket = useLeftHand\r\n      ? (isBackFrame ? SOCKET_BACK_L : SOCKET_FRONT_L)\r\n      : (isBackFrame ? SOCKET_BACK_R : SOCKET_FRONT_R);\r\n\r\n    let sx = socket.x;\r\n    if (currentFrame.flipX) sx *= -1;\r\n\r\n    return { x: sx, y: socket.y };\r\n  }\r\n};\r\n\r\n/**\r\n * StaffPositioning: Specific sockets and logic for the Void Staff\r\n */\r\nexport const StaffPositioning = {\r\n  getHandSocket(p: PlayerState, time: number): { x: number, y: number } {\r\n    const frameOrFrames = getSpriteFrameForFacing(p);\r\n    const moves = p.isMoving || p.isDashing || p.meleeAttacking;\r\n    const currentFrame = Array.isArray(frameOrFrames)\r\n      ? frameOrFrames[Math.floor(time * (moves ? 10 : 1.2)) % frameOrFrames.length]\r\n      : frameOrFrames;\r\n\r\n    const isBackFrame = currentFrame.src.includes('costa');\r\n    // Staff always in primary hand (usually Right Hand)\r\n    const socket = currentFrame.handSocket || (isBackFrame ? SOCKET_BACK_R : SOCKET_FRONT_R);\r\n\r\n    let sx = socket.x;\r\n    if (currentFrame.flipX) sx *= -1;\r\n\r\n    return { x: sx, y: socket.y };\r\n  },\r\n\r\n  getTipSocketWorld(p: PlayerState, time: number): { x: number, y: number } {\r\n    const hand = this.getHandSocket(p, time);\r\n    // Tip is 48px above hand in vertical pose\r\n    return { x: p.x + hand.x, y: p.y + hand.y - 48 };\r\n  }\r\n};\r\n\r\n/**\r\n * HandCastEffect: Visual feedback on the hand before firing\r\n */\r\nexport const HandCastEffect = {\r\n  render(ctx: CanvasRenderingContext2D, p: PlayerState, time: number) {\r\n    if (!p.isRangedCharging) return;\r\n\r\n    const socket = ProjectileOrigin.getHandSocket(p, time);\r\n    const hx = p.x + socket.x;\r\n    const hy = p.y + socket.y;\r\n\r\n    // 0.2s charge duration\r\n    const progress = Math.max(0, 1 - p.rangedChargeTimer / 0.17);\r\n\r\n    ctx.save();\r\n\r\n    // Core Glow (Roxo Escuro Elegante)\r\n    const g = ctx.createRadialGradient(hx, hy, 0, hx, hy, 8 * progress);\r\n    g.addColorStop(0, 'rgba(200, 160, 255, 0.9)'); // Bright core\r\n    g.addColorStop(0.5, 'rgba(100, 30, 220, 0.4)'); // Purple energy\r\n    g.addColorStop(1, 'rgba(40, 0, 80, 0)');\r\n\r\n    ctx.fillStyle = g;\r\n    ctx.beginPath();\r\n    ctx.arc(hx, hy, 12 * progress, 0, Math.PI * 2);\r\n    ctx.fill();\r\n\r\n    // Pulse effect\r\n    const pulse = 1 + Math.sin(time * 25) * 0.2;\r\n    ctx.strokeStyle = 'rgba(180, 100, 255, 0.6)';\r\n    ctx.lineWidth = 1;\r\n    ctx.beginPath();\r\n    ctx.arc(hx, hy, (6 + Math.sin(time * 15) * 2) * progress, 0, Math.PI * 2);\r\n    ctx.stroke();\r\n\r\n    // Swirling particles\r\n    for (let i = 0; i < 3; i++) {\r\n      const ang = time * 8 + i * (Math.PI * 2 / 3);\r\n      const dist = 6 + Math.sin(time * 10 + i) * 2;\r\n      ctx.fillStyle = 'rgba(220, 180, 255, 0.8)';\r\n      ctx.beginPath();\r\n      ctx.arc(hx + Math.cos(ang) * dist, hy + Math.sin(ang) * dist, 1, 0, Math.PI * 2);\r\n      ctx.fill();\r\n    }\r\n\r\n    ctx.restore();\r\n  },\r\n\r\n  renderFlash(particles: Particle[], x: number, y: number) {\r\n    // Quick flash at hand on fire\r\n    particles.push({\r\n      x, y, vx: 0, vy: 0,\r\n      life: 0.08, maxLife: 0.08,\r\n      size: 18, color: '#ffffff',\r\n      type: 'explosion'\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * EnemyProjectileVisual\r\n * Dispatches to the correct per-kind renderer based on projectileKind tag.\r\n */\r\nexport const EnemyProjectileVisual = {\r\n  render(ctx: CanvasRenderingContext2D, p: ProjectileState, time: number) {\r\n    const alpha = Math.max(0, p.lifetime / (p.maxLifetime || 1));\r\n    ctx.save();\r\n    ctx.globalAlpha = alpha;\r\n    switch (p.projectileKind) {\r\n      case 'needle': this._drawNeedle(ctx, p, time); break;\r\n      case 'heavy': this._drawHeavy(ctx, p, time); break;\r\n      case 'boss_orb': this._drawBossOrb(ctx, p, time); break;\r\n      case 'boss_arc': this._drawBossArc(ctx, p, time); break;\r\n      case 'boss_void': this._drawBossVoid(ctx, p, time); break;\r\n      case 'boss_frag': this._drawBossFrag(ctx, p, time); break;\r\n      default: this._drawBasic(ctx, p, time); break;\r\n    }\r\n    ctx.restore();\r\n  },\r\n\r\n  _drawBasic(ctx: CanvasRenderingContext2D, p: ProjectileState, _time: number) {\r\n    const r = p.size;\r\n    const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r * 1.8);\r\n    g.addColorStop(0, 'rgba(255, 80, 80, 0.95)');\r\n    g.addColorStop(0.5, 'rgba(160, 20, 20, 0.7)');\r\n    g.addColorStop(1, 'rgba(80, 0, 0, 0)');\r\n    ctx.fillStyle = g;\r\n    ctx.beginPath();\r\n    ctx.arc(p.x, p.y, r * 1.8, 0, Math.PI * 2);\r\n    ctx.fill();\r\n    ctx.fillStyle = 'rgba(255, 200, 200, 0.9)';\r\n    ctx.beginPath();\r\n    ctx.arc(p.x, p.y, r * 0.4, 0, Math.PI * 2);\r\n    ctx.fill();\r\n  },\r\n\r\n  _drawNeedle(ctx: CanvasRenderingContext2D, p: ProjectileState, _time: number) {\r\n    ctx.save();\r\n    ctx.translate(p.x, p.y);\r\n    ctx.rotate(p.angle);\r\n    const len = p.size * 5.5;\r\n    const w = p.size * 0.45;\r\n    const g = ctx.createLinearGradient(-len / 2, 0, len / 2, 0);\r\n    g.addColorStop(0, 'rgba(255, 140, 0, 0)');\r\n    g.addColorStop(0.35, 'rgba(255, 200, 80, 0.9)');\r\n    g.addColorStop(0.75, 'rgba(255, 255, 160, 1)');\r\n    g.addColorStop(1, 'rgba(255, 100, 0, 0)');\r\n    ctx.fillStyle = g;\r\n    ctx.beginPath();\r\n    ctx.ellipse(0, 0, len / 2, w, 0, 0, Math.PI * 2);\r\n    ctx.fill();\r\n    ctx.fillStyle = '#ffffff';\r\n    ctx.beginPath();\r\n    ctx.arc(len * 0.35, 0, w * 0.6, 0, Math.PI * 2);\r\n    ctx.fill();\r\n    ctx.restore();\r\n  },\r\n\r\n  _drawHeavy(ctx: CanvasRenderingContext2D, p: ProjectileState, time: number) {\r\n    const r = p.size;\r\n    const pulse = 1 + Math.sin(time * 8 + p.x) * 0.18;\r\n    const rp = r * pulse;\r\n    const aura = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, rp * 2.8);\r\n    aura.addColorStop(0, 'rgba(255, 60, 0, 0.3)');\r\n    aura.addColorStop(1, 'rgba(180, 0, 0, 0)');\r\n    ctx.fillStyle = aura;\r\n    ctx.beginPath();\r\n    ctx.arc(p.x, p.y, rp * 2.8, 0, Math.PI * 2);\r\n    ctx.fill();\r\n    const core = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, rp);\r\n    core.addColorStop(0, '#ffcc44');\r\n    core.addColorStop(0.4, '#ff5500');\r\n    core.addColorStop(1, '#220000');\r\n    ctx.fillStyle = core;\r\n    ctx.beginPath();\r\n    ctx.arc(p.x, p.y, rp, 0, Math.PI * 2);\r\n    ctx.fill();\r\n    ctx.strokeStyle = `rgba(255, 120, 0, ${0.5 + Math.sin(time * 10) * 0.3})`;\r\n    ctx.lineWidth = 1.5;\r\n    ctx.beginPath();\r\n    ctx.arc(p.x, p.y, rp * 1.5, 0, Math.PI * 2);\r\n    ctx.stroke();\r\n  },\r\n\r\n  _drawBossOrb(ctx: CanvasRenderingContext2D, p: ProjectileState, time: number) {\r\n    const r = p.size;\r\n    const pulse = 1 + Math.sin(time * 12) * 0.12;\r\n    const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r * pulse * 2.2);\r\n    g.addColorStop(0, 'rgba(220, 180, 255, 1)');\r\n    g.addColorStop(0.3, 'rgba(120, 40, 220, 0.9)');\r\n    g.addColorStop(0.7, 'rgba(50, 0, 120, 0.6)');\r\n    g.addColorStop(1, 'rgba(20, 0, 60, 0)');\r\n    ctx.fillStyle = g;\r\n    ctx.beginPath();\r\n    ctx.arc(p.x, p.y, r * pulse * 2.2, 0, Math.PI * 2);\r\n    ctx.fill();\r\n    ctx.fillStyle = '#ffffff';\r\n    ctx.beginPath();\r\n    ctx.arc(p.x, p.y, r * 0.4 * pulse, 0, Math.PI * 2);\r\n    ctx.fill();\r\n  },\r\n\r\n  _drawBossArc(ctx: CanvasRenderingContext2D, p: ProjectileState, time: number) {\r\n    ctx.save();\r\n    ctx.translate(p.x, p.y);\r\n    ctx.rotate(p.angle);\r\n    const w = p.size * 2.4;\r\n    const h = p.size * 0.65;\r\n    const wobble = Math.sin(time * 20) * 0.8;\r\n    ctx.shadowBlur = 10;\r\n    ctx.shadowColor = 'rgba(0, 40, 200, 0.8)';\r\n    ctx.fillStyle = 'rgba(20, 20, 200, 0.9)';\r\n    ctx.beginPath();\r\n    ctx.moveTo(-w / 2, wobble);\r\n    ctx.quadraticCurveTo(0, -h + wobble, w / 2, wobble);\r\n    ctx.quadraticCurveTo(0, h + wobble, -w / 2, wobble);\r\n    ctx.fill();\r\n    ctx.shadowBlur = 0;\r\n    const cg = ctx.createLinearGradient(-w / 2, 0, w / 2, 0);\r\n    cg.addColorStop(0, 'rgba(100, 180, 255, 0)');\r\n    cg.addColorStop(0.5, 'rgba(180, 220, 255, 0.9)');\r\n    cg.addColorStop(1, 'rgba(100, 180, 255, 0)');\r\n    ctx.fillStyle = cg;\r\n    ctx.beginPath();\r\n    ctx.moveTo(-w / 2, wobble);\r\n    ctx.quadraticCurveTo(0, -h * 0.4 + wobble, w / 2, wobble);\r\n    ctx.quadraticCurveTo(0, h * 0.4 + wobble, -w / 2, wobble);\r\n    ctx.fill();\r\n    ctx.restore();\r\n  },\r\n\r\n  _drawBossVoid(ctx: CanvasRenderingContext2D, p: ProjectileState, _time: number) {\r\n    ctx.save();\r\n    ctx.translate(p.x, p.y);\r\n    ctx.rotate(p.angle);\r\n    const len = p.size * 5;\r\n    const w = p.size * 0.6;\r\n    const tg = ctx.createLinearGradient(-len * 0.8, 0, 0, 0);\r\n    tg.addColorStop(0, 'rgba(0, 255, 220, 0)');\r\n    tg.addColorStop(1, 'rgba(0, 200, 180, 0.2)');\r\n    ctx.fillStyle = tg;\r\n    ctx.fillRect(-len * 0.8, -w * 2, len * 0.8, w * 4);\r\n    const bg = ctx.createLinearGradient(0, -w, 0, w);\r\n    bg.addColorStop(0, 'rgba(100, 255, 240, 0)');\r\n    bg.addColorStop(0.4, 'rgba(220, 255, 255, 0.95)');\r\n    bg.addColorStop(0.6, 'rgba(220, 255, 255, 0.95)');\r\n    bg.addColorStop(1, 'rgba(100, 255, 240, 0)');\r\n    ctx.fillStyle = bg;\r\n    ctx.beginPath();\r\n    ctx.ellipse(0, 0, len * 0.5, w, 0, 0, Math.PI * 2);\r\n    ctx.fill();\r\n    ctx.fillStyle = '#ffffff';\r\n    ctx.beginPath();\r\n    ctx.arc(len * 0.42, 0, w * 0.65, 0, Math.PI * 2);\r\n    ctx.fill();\r\n    ctx.restore();\r\n  },\r\n\r\n  _drawBossFrag(ctx: CanvasRenderingContext2D, p: ProjectileState, time: number) {\r\n    ctx.save();\r\n    ctx.translate(p.x, p.y);\r\n    ctx.rotate(time * 6 + p.x * 0.1);\r\n    const s = p.size;\r\n    const aura = ctx.createRadialGradient(0, 0, 0, 0, 0, s * 2.8);\r\n    aura.addColorStop(0, 'rgba(255, 80, 200, 0.4)');\r\n    aura.addColorStop(1, 'rgba(100, 0, 200, 0)');\r\n    ctx.fillStyle = aura;\r\n    ctx.beginPath();\r\n    ctx.arc(0, 0, s * 2.8, 0, Math.PI * 2);\r\n    ctx.fill();\r\n    ctx.fillStyle = 'rgba(200, 120, 255, 0.92)';\r\n    ctx.beginPath();\r\n    ctx.moveTo(0, -s * 1.6);\r\n    ctx.lineTo(s * 1.1, -s * 0.4);\r\n    ctx.lineTo(s * 0.7, s * 1.2);\r\n    ctx.lineTo(-s * 0.5, s * 0.9);\r\n    ctx.lineTo(-s * 1.2, -s * 0.6);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n    ctx.fillStyle = '#ffe0ff';\r\n    ctx.beginPath();\r\n    ctx.arc(0, 0, s * 0.4, 0, Math.PI * 2);\r\n    ctx.fill();\r\n    ctx.restore();\r\n  },\r\n};\r\n\r\n/**\r\n * ProjectileVisual: Logic for drawing the \"Corte de V├ícuo Energizado\"\r\n */\r\nexport const ProjectileVisual = {\r\n  render(ctx: CanvasRenderingContext2D, p: ProjectileState, time: number) {\r\n    if (!p.isPlayerOwned) {\r\n      EnemyProjectileVisual.render(ctx, p, time);\r\n      return;\r\n    }\r\n\r\n    const lifeRatio = Math.max(0, p.lifetime / p.maxLifetime);\r\n\r\n    if (p.projectileKind === 'staff_bolt') {\r\n      this._renderStaffBolt(ctx, p, time, lifeRatio);\r\n      return;\r\n    }\r\n\r\n    ctx.save();\r\n    ctx.translate(p.x, p.y);\r\n    ctx.rotate(p.angle);\r\n\r\n    ctx.globalAlpha = Math.min(1, lifeRatio * 1.5);\r\n\r\n    // 1. Light Trail (Rastro leve)\r\n    const trailLen = 22;\r\n    const trailAlpha = 0.12 * lifeRatio;\r\n    ctx.beginPath();\r\n    ctx.strokeStyle = `rgba(160, 80, 255, ${trailAlpha})`;\r\n    ctx.lineWidth = p.size * 0.4;\r\n    ctx.lineCap = 'round';\r\n    ctx.moveTo(-trailLen, 0);\r\n    ctx.quadraticCurveTo(-trailLen / 2, 2, 0, 0);\r\n    ctx.stroke();\r\n\r\n    // 2. High Presence Slash Shape (Presen├ºa clara e marcante)\r\n    const w = p.size * 1.5; // Wider for presence\r\n    const h = p.size * 0.45; // Thicker\r\n\r\n    // Elegant Dark Purple Borders\r\n    ctx.shadowBlur = 10;\r\n    ctx.shadowColor = 'rgba(60, 0, 120, 0.9)';\r\n\r\n    const wobble = Math.sin(time * 30) * 1.2;\r\n\r\n    // Outer Border (Dark Purple with center fade)\r\n    const bGrad = ctx.createLinearGradient(0, -h, 0, h);\r\n    bGrad.addColorStop(0, 'rgba(80, 0, 150, 0)');\r\n    bGrad.addColorStop(0.5, 'rgba(100, 30, 220, 0.95)');\r\n    bGrad.addColorStop(1, 'rgba(80, 0, 150, 0)');\r\n\r\n    ctx.fillStyle = 'rgba(60, 0, 140, 0.95)';\r\n    ctx.beginPath();\r\n    ctx.moveTo(-w / 2, 0 + wobble);\r\n    ctx.quadraticCurveTo(0, -h + wobble, w / 2, 0 + wobble);\r\n    ctx.quadraticCurveTo(0, h + wobble, -w / 2, 0 + wobble);\r\n    ctx.fill();\r\n\r\n    // Core (Lighter center / White core)\r\n    const coreH = h * 0.5;\r\n    const coreW = w * 0.75;\r\n    const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, coreW / 2);\r\n    coreGrad.addColorStop(0, '#ffffff');\r\n    coreGrad.addColorStop(1, 'rgba(200, 150, 255, 0.5)');\r\n\r\n    ctx.fillStyle = coreGrad;\r\n    ctx.beginPath();\r\n    ctx.moveTo(-coreW / 2, 0 + wobble);\r\n    ctx.quadraticCurveTo(0, -coreH + wobble, coreW / 2, 0 + wobble);\r\n    ctx.quadraticCurveTo(0, coreH + wobble, -coreW / 2, 0 + wobble);\r\n    ctx.fill();\r\n\r\n    // 3. Air Distortion \r\n    ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';\r\n    ctx.lineWidth = 0.5;\r\n    ctx.beginPath();\r\n    ctx.moveTo(-w / 2, -2);\r\n    ctx.lineTo(-w / 2 - 5, -8);\r\n    ctx.stroke();\r\n\r\n    ctx.restore();\r\n  },\r\n\r\n  _renderStaffBolt(ctx: CanvasRenderingContext2D, p: ProjectileState, time: number, lifeRatio: number) {\r\n    ctx.save();\r\n    ctx.translate(p.x, p.y);\r\n    ctx.rotate(p.angle);\r\n\r\n    // Scaling and alpha based on life\r\n    const scale = 0.8 + (1 - lifeRatio) * 0.4;\r\n    ctx.scale(scale, scale);\r\n    ctx.globalAlpha = Math.min(1, lifeRatio * 2);\r\n\r\n    // 1. Elegant Trail (Ethereal ribbon)\r\n    const trailLen = 30;\r\n    const trailG = ctx.createLinearGradient(-trailLen, 0, 0, 0);\r\n    trailG.addColorStop(0, 'rgba(100, 0, 200, 0)');\r\n    trailG.addColorStop(0.5, 'rgba(150, 50, 255, 0.2)');\r\n    trailG.addColorStop(1, 'rgba(200, 150, 255, 0.5)');\r\n\r\n    ctx.fillStyle = trailG;\r\n    ctx.beginPath();\r\n    ctx.moveTo(0, -p.size);\r\n    ctx.quadraticCurveTo(-trailLen / 2, -p.size * 1.5, -trailLen, 0);\r\n    ctx.quadraticCurveTo(-trailLen / 2, p.size * 1.5, 0, p.size);\r\n    ctx.fill();\r\n\r\n    // 2. Air Distortion Bloom (Refraction effect)\r\n    ctx.save();\r\n    ctx.globalAlpha *= 0.3;\r\n    ctx.fillStyle = 'rgba(200, 220, 255, 0.2)';\r\n    ctx.beginPath();\r\n    ctx.ellipse(0, 0, p.size * 2.2, p.size * 1.5, 0, 0, Math.PI * 2);\r\n    ctx.fill();\r\n    ctx.restore();\r\n\r\n    // 3. Dimensional Nucleus (The crystal)\r\n    const auraG = ctx.createRadialGradient(0, 0, 0, 0, 0, p.size * 1.5);\r\n    auraG.addColorStop(0, 'rgba(180, 100, 255, 0.6)');\r\n    auraG.addColorStop(1, 'rgba(80, 0, 150, 0)');\r\n    ctx.fillStyle = auraG;\r\n    ctx.beginPath();\r\n    ctx.arc(0, 0, p.size * 1.5, 0, Math.PI * 2);\r\n    ctx.fill();\r\n\r\n    ctx.fillStyle = '#ffffff';\r\n    ctx.shadowBlur = 12;\r\n    ctx.shadowColor = '#8844ff';\r\n\r\n    ctx.beginPath();\r\n    const cw = p.size * 1.2;\r\n    const ch = p.size * 0.6;\r\n    ctx.moveTo(cw, 0); ctx.lineTo(0, -ch); ctx.lineTo(-cw, 0); ctx.lineTo(0, ch);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n\r\n    ctx.restore();\r\n  },\r\n};\r\n\r\n/**\r\n * StaffChargeEffect: Visual accumulation on staff tip\r\n */\r\nexport const StaffChargeEffect = {\r\n  render(ctx: CanvasRenderingContext2D, p: PlayerState, time: number) {\r\n    if (!p.isStaffCharging) return;\r\n    const tip = StaffPositioning.getTipSocketWorld(p, time);\r\n\r\n    ctx.save();\r\n    ctx.translate(tip.x, tip.y);\r\n    const progress = 1 - (p.staffChargeTimer / 0.26);\r\n    const pulse = 1 + Math.sin(time * 30) * 0.2;\r\n    const size = 15 * progress * pulse;\r\n\r\n    const bloom = ctx.createRadialGradient(0, 0, 0, 0, 0, size);\r\n    bloom.addColorStop(0, '#ffffff');\r\n    bloom.addColorStop(0.4, 'rgba(150, 50, 255, 0.9)');\r\n    bloom.addColorStop(1, 'rgba(80, 0, 120, 0)');\r\n    ctx.fillStyle = bloom;\r\n    ctx.beginPath(); ctx.arc(0, 0, size, 0, Math.PI * 2); ctx.fill();\r\n\r\n    ctx.restore();\r\n  }\r\n};\r\n\r\n/**\r\n * StaffImpactEffect: AAA dimensional explosion\r\n */\r\nexport const StaffImpactEffect = {\r\n  spawn(particles: Particle[], x: number, y: number) {\r\n    particles.push({\r\n      x, y, vx: 0, vy: 0, life: 0.2, maxLife: 0.2, size: 45, color: '#ffffff', type: 'explosion'\r\n    });\r\n    for (let i = 0; i < 12; i++) {\r\n      const a = Math.random() * Math.PI * 2, s = 150 + Math.random() * 150;\r\n      particles.push({\r\n        x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s,\r\n        life: 0.4 + Math.random() * 0.3, maxLife: 0.7, size: 2 + Math.random() * 4,\r\n        color: i % 2 === 0 ? '#aa66ff' : '#00ffff', type: 'spark'\r\n      });\r\n    }\r\n  }\r\n};\r\n\r\nexport function renderProjectile(ctx: CanvasRenderingContext2D, p: ProjectileState, time: number) {\r\n  ProjectileVisual.render(ctx, p, time);\r\n}\r\n\r\n/**\r\n * ImpactEffect: Visual feedback for Vacuum Slash hitting a target\r\n */\r\nexport const ImpactEffect = {\r\n  spawn(particles: Particle[], x: number, y: number) {\r\n    // Flash at impact point\r\n    particles.push({\r\n      x, y, vx: 0, vy: 0,\r\n      life: 0.15, maxLife: 0.15,\r\n      size: 20, color: 'rgba(255, 255, 255, 0.82)',\r\n      type: 'explosion'\r\n    });\r\n\r\n    // Cutting particles dispersing\r\n    for (let i = 0; i < 8; i++) {\r\n      const angle = Math.random() * Math.PI * 2;\r\n      const speed = 40 + Math.random() * 60;\r\n      particles.push({\r\n        x, y,\r\n        vx: Math.cos(angle) * speed,\r\n        vy: Math.sin(angle) * speed,\r\n        life: 0.3 + Math.random() * 0.2,\r\n        maxLife: 0.5,\r\n        size: 1 + Math.random() * 2,\r\n        color: Math.random() > 0.4 ? '#ffffff' : '#8844ff',\r\n        type: 'spark'\r\n      });\r\n    }\r\n  }\r\n};\r\n\r\nexport function spawnVacuumImpact(particles: Particle[], x: number, y: number) {\r\n  ImpactEffect.spawn(particles, x, y);\r\n}\r\n\r\n/**\r\n * EnemyProjectileImpact\r\n * Dispatches unique visual feedback based on projectileKind.\r\n */\r\nexport const EnemyProjectileImpact = {\r\n  spawn(particles: Particle[], p: ProjectileState) {\r\n    const x = p.x, y = p.y;\r\n    switch (p.projectileKind) {\r\n      case 'needle':\r\n        // Sharp orange spark\r\n        for (let i = 0; i < 4; i++) {\r\n          const a = p.angle + Math.PI + (Math.random() - 0.5) * 1.5;\r\n          const s = 100 + Math.random() * 80;\r\n          particles.push({\r\n            x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s,\r\n            life: 0.2, maxLife: 0.2, size: 1.5, color: '#ffcc00', type: 'spark'\r\n          });\r\n        }\r\n        break;\r\n      case 'heavy':\r\n        // Dark crimson explosion\r\n        for (let i = 0; i < 12; i++) {\r\n          const a = Math.random() * Math.PI * 2;\r\n          const s = 40 + Math.random() * 60;\r\n          particles.push({\r\n            x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s,\r\n            life: 0.4, maxLife: 0.4, size: 3, color: '#aa0000', type: 'spark'\r\n          });\r\n        }\r\n        break;\r\n      case 'boss_void':\r\n        // Purple void dispersion\r\n        for (let i = 0; i < 10; i++) {\r\n          const a = Math.random() * Math.PI * 2;\r\n          const s = 20 + Math.random() * 40;\r\n          particles.push({\r\n            x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s,\r\n            life: 0.6, maxLife: 0.6, size: 4, color: '#4400aa', type: 'ghost'\r\n          });\r\n        }\r\n        break;\r\n      case 'boss_orb':\r\n      case 'boss_arc':\r\n      case 'boss_frag':\r\n        // Azure/Cyan mystical explosion\r\n        for (let i = 0; i < 15; i++) {\r\n          const a = Math.random() * Math.PI * 2;\r\n          const s = 50 + Math.random() * 70;\r\n          particles.push({\r\n            x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s,\r\n            life: 0.5, maxLife: 0.5, size: 2.5, color: '#00ffff', type: 'spark'\r\n          });\r\n        }\r\n        particles.push({\r\n          x, y, vx: 0, vy: 0, life: 0.2, maxLife: 0.2, size: 30, color: 'rgba(0, 255, 255, 0.4)', type: 'explosion'\r\n        });\r\n        break;\r\n      default:\r\n        // Standard red impact\r\n        particles.push({\r\n          x, y, vx: 0, vy: 0, life: 0.1, maxLife: 0.1, size: 15, color: '#ff4444', type: 'explosion'\r\n        });\r\n        break;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Render a Dimensional Rift (Victory/Progression Portal)\r\n */\r\nexport function renderDimensionalRift(ctx: CanvasRenderingContext2D, portal: Portal, time: number, playerX: number, playerY: number) {\r\n  const { x, y, state } = portal;\r\n  const dx = playerX - x;\r\n  const dy = playerY - y;\r\n  const dist = Math.sqrt(dx * dx + dy * dy);\r\n\r\n  // Proximity pulsation factor\r\n  const isNear = dist < 70;\r\n  const proximityMult = isNear ? 2.5 : 1.0;\r\n  const pulse = Math.sin(time * 3 * proximityMult) * 0.1 + 0.95;\r\n\r\n  ctx.save();\r\n  ctx.translate(x, y);\r\n\r\n  // 1. Extreme Ambient Glow\r\n  const glowAlpha = (state === 'locked' ? 0.2 : state === 'completed' ? 0.1 : 0.5) * pulse;\r\n  const baseColor = state === 'completed' ? '120, 100, 180' : '100, 40, 255';\r\n  const glowGrad = ctx.createRadialGradient(0, 0, 10, 0, 0, 80 * pulse);\r\n  glowGrad.addColorStop(0, `rgba(${baseColor}, ${glowAlpha})`);\r\n  glowGrad.addColorStop(0.4, `rgba(${baseColor}, ${glowAlpha * 0.5})`);\r\n  glowGrad.addColorStop(1, `rgba(${baseColor}, 0)`);\r\n  ctx.fillStyle = glowGrad;\r\n  ctx.beginPath();\r\n  ctx.ellipse(0, 0, 50 * pulse, 100 * pulse, 0, 0, Math.PI * 2);\r\n  ctx.fill();\r\n\r\n  // 2. The Void Core (Smooth Ellipse)\r\n  ctx.fillStyle = '#010003';\r\n  ctx.beginPath();\r\n  ctx.ellipse(0, 0, 18 * pulse, 62 * pulse, 0, 0, Math.PI * 2);\r\n  ctx.fill();\r\n\r\n  // 3. Dimensional Energy Layers (Jagged shimmering edges)\r\n  const layerCount = 2;\r\n  for (let l = 0; l < layerCount; l++) {\r\n    const lPulse = Math.sin(time * 4 + l) * 0.1 + 1.0;\r\n    ctx.strokeStyle = l === 0 ? `rgba(180, 100, 255, ${0.4 * pulse})` : `rgba(220, 180, 255, ${0.2 * pulse})`;\r\n    ctx.lineWidth = l === 0 ? 2 : 1;\r\n    ctx.beginPath();\r\n    const h = (65 + l * 5) * pulse;\r\n    const w = (22 + l * 4) * pulse;\r\n    ctx.moveTo(0, -h);\r\n    for (let i = -h; i <= h; i += 8) {\r\n      const taper = 1 - Math.pow(i / h, 2);\r\n      const noise = Math.sin(time * 5 + i * 0.3) * 4;\r\n      ctx.lineTo((w + noise) * taper, i);\r\n    }\r\n    for (let i = h; i >= -h; i -= 8) {\r\n      const taper = 1 - Math.pow(i / h, 2);\r\n      const noise = Math.cos(time * 4 - i * 0.25) * 4;\r\n      ctx.lineTo((-w + noise) * taper, i);\r\n    }\r\n    ctx.closePath();\r\n    ctx.stroke();\r\n  }\r\n\r\n  // 4. Vortex Suction Particles (Vibrant energy spiraling in)\r\n  if (state === 'available') {\r\n    const particleCount = isNear ? 20 : 10;\r\n    for (let i = 0; i < particleCount; i++) {\r\n      const seed = (i * Math.E) + (portal.id.length * 0.7);\r\n      const pTime = (time * 0.6 + seed) % 1;\r\n      const pDist = (100 * (1 - pTime)) + 4;\r\n      // Spiral motion: angle increases as it gets closer\r\n      const spiralSpeed = 8;\r\n      const pAngle = (seed * 15) + (pTime * spiralSpeed);\r\n\r\n      const px = Math.cos(pAngle) * pDist;\r\n      const py = Math.sin(pAngle) * pDist;\r\n\r\n      const size = 1.2 + pTime * 1.5;\r\n      ctx.fillStyle = `rgba(180, 140, 255, ${0.4 + pTime * 0.6})`;\r\n      ctx.fillRect(px, py, size, size);\r\n\r\n      // Secondary trailing glow for particles\r\n      if (isNear) {\r\n        ctx.fillStyle = `rgba(100, 50, 255, ${0.4 * pTime})`;\r\n        ctx.fillRect(px - 1, py - 1, size + 2, size + 2);\r\n      }\r\n    }\r\n  }\r\n\r\n  ctx.restore();\r\n\r\n  // 5. Majestic Prompt (Exactly as requested)\r\n  if (state !== 'locked' && state !== 'completed' && dist < 100) {\r\n    ctx.save();\r\n    ctx.textAlign = 'center';\r\n\r\n    const floatY = Math.sin(time * 4) * 4;\r\n    const alpha = 0.7 + Math.sin(time * 3) * 0.25;\r\n\r\n    ctx.shadowBlur = 12;\r\n    ctx.shadowColor = 'black';\r\n\r\n    ctx.fillStyle = `rgba(210, 190, 255, ${alpha})`;\r\n    ctx.font = `700 11px ${C.HUD_FONT}`;\r\n    ctx.fillText('AVAN├çAR PARA PR├ôXIMO ANDAR', x, y - 82 + floatY);\r\n\r\n    ctx.font = `600 9px ${C.HUD_FONT}`;\r\n    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;\r\n    ctx.fillText('APROXIME-SE OU PRESSIONE [E]', x, y - 68 + floatY);\r\n    ctx.restore();\r\n  }\r\n}\r\n\r\nexport function renderParticles(ctx: CanvasRenderingContext2D, particles: Particle[]) {\r\n  for (const p of particles) {\r\n    const alpha = Math.max(0, p.life / p.maxLife);\r\n    if (p.type === 'text' && p.text) {\r\n      ctx.globalAlpha = alpha;\r\n      ctx.font = `500 ${p.size}px ${C.HUD_FONT}`;\r\n      ctx.textAlign = 'left';\r\n      drawHudText(ctx, p.text, Math.floor(p.x), Math.floor(p.y), p.color, 0.5);\r\n      ctx.globalAlpha = 1;\r\n    } else if (p.type === 'shockwave' && p.radius !== undefined) {\r\n      ctx.strokeStyle = p.color;\r\n      ctx.globalAlpha = alpha * 0.6;\r\n      ctx.lineWidth = 2;\r\n      ctx.beginPath();\r\n      ctx.arc(Math.floor(p.x), Math.floor(p.y), p.radius, 0, Math.PI * 2);\r\n      ctx.stroke();\r\n      ctx.globalAlpha = 1;\r\n    } else if (p.type === 'ghost') {\r\n      ctx.globalAlpha = alpha * 0.5;\r\n      ctx.fillStyle = p.color;\r\n      ctx.beginPath();\r\n      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);\r\n      ctx.fill();\r\n      ctx.globalAlpha = 1;\r\n    } else if (p.type === 'soul') {\r\n      // Soul collection: glowing blue energy orb\r\n      ctx.globalAlpha = alpha * 0.85;\r\n      const glow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 2);\r\n      glow.addColorStop(0, p.color);\r\n      glow.addColorStop(0.5, p.color.replace(')', ', 0.4)').replace('hsl', 'hsla'));\r\n      glow.addColorStop(1, 'rgba(60, 120, 220, 0)');\r\n      ctx.fillStyle = glow;\r\n      ctx.beginPath();\r\n      ctx.arc(p.x, p.y, p.size * 2.5, 0, Math.PI * 2);\r\n      ctx.fill();\r\n      // Core\r\n      ctx.fillStyle = '#aaddff';\r\n      ctx.beginPath();\r\n      ctx.arc(p.x, p.y, p.size * 0.5, 0, Math.PI * 2);\r\n      ctx.fill();\r\n      ctx.globalAlpha = 1;\r\n    } else if (p.type === 'fog') {\r\n      ctx.globalAlpha = alpha * 0.3;\r\n      ctx.fillStyle = p.color;\r\n      ctx.beginPath();\r\n      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);\r\n      ctx.fill();\r\n      ctx.globalAlpha = 1;\r\n    } else if (p.type === 'explosion') {\r\n      ctx.globalAlpha = alpha * 0.5;\r\n      const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);\r\n      g.addColorStop(0, p.color);\r\n      g.addColorStop(1, 'rgba(255, 255, 255, 0)');\r\n      ctx.fillStyle = g;\r\n      ctx.beginPath();\r\n      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);\r\n      ctx.fill();\r\n      ctx.globalAlpha = 1;\r\n    } else if (p.type === 'dimensional_shard') {\r\n      ctx.globalAlpha = alpha * 0.8;\r\n      ctx.fillStyle = p.color;\r\n      ctx.shadowBlur = 4;\r\n      ctx.shadowColor = p.color;\r\n\r\n      const size = p.size * (0.8 + alpha * 0.4); // slightly shrink\r\n      ctx.save();\r\n      ctx.translate(p.x, p.y);\r\n      if (p.angle !== undefined) ctx.rotate(p.angle);\r\n\r\n      // Draw a sharp diamond/shard shape\r\n      ctx.beginPath();\r\n      ctx.moveTo(0, -size * 1.5);\r\n      ctx.lineTo(size, 0);\r\n      ctx.lineTo(0, size * 1.5);\r\n      ctx.lineTo(-size, 0);\r\n      ctx.closePath();\r\n      ctx.fill();\r\n\r\n      ctx.restore();\r\n      ctx.shadowBlur = 0;\r\n      ctx.globalAlpha = 1;\r\n    } else if (p.type === 'spark') {\r\n      ctx.globalAlpha = alpha;\r\n      ctx.fillStyle = p.color;\r\n      ctx.beginPath();\r\n      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);\r\n      ctx.fill();\r\n      ctx.globalAlpha = 1;\r\n    } else {\r\n      ctx.globalAlpha = alpha;\r\n      ctx.fillStyle = p.color;\r\n      ctx.fillRect(Math.floor(p.x - p.size / 2), Math.floor(p.y - p.size / 2), Math.ceil(p.size), Math.ceil(p.size));\r\n      ctx.globalAlpha = 1;\r\n    }\r\n  }\r\n}\r\n\r\nexport function renderLighting(ctx: CanvasRenderingContext2D, px: number, py: number, radius: number, vp: Viewport, isVendorRoom: boolean = false) {\r\n  const brightness = getBrightness(); // Range [-0.5, 0.5]\r\n\r\n  // Dynamic FOV: Shrink the light radius further if brightness is very low\r\n  // When brightness starts going below -0.2, we close the field of vision\r\n  let effectiveRadius = radius;\r\n  if (brightness < -0.2) {\r\n    const radiusFactor = Math.max(0.4, 1 + (brightness + 0.2) * 2); // At -0.5, radius is 40%\r\n    effectiveRadius *= radiusFactor;\r\n  }\r\n\r\n  if (isVendorRoom) {\r\n    // Vendor room: very bright, warm light\r\n    // Scale the ambient shadow opacity based on brightness\r\n    const baseAlpha = 0.4;\r\n    const alphaScale = Math.max(0, 1 - (brightness + 0.5)); // +0.5 brightness -> alpha 0\r\n    const finalAlpha = baseAlpha * alphaScale;\r\n\r\n    const gradient = ctx.createRadialGradient(px, py, effectiveRadius * 0.5, px, py, effectiveRadius * 1.5);\r\n    gradient.addColorStop(0, 'rgba(5, 3, 10, 0)');\r\n    gradient.addColorStop(0.6, `rgba(5, 3, 10, ${finalAlpha * 0.25})`);\r\n    gradient.addColorStop(1, `rgba(5, 3, 10, ${finalAlpha})`);\r\n    ctx.fillStyle = gradient;\r\n    ctx.fillRect(-vp.gox, -vp.goy, vp.rw, vp.rh);\r\n    return;\r\n  }\r\n\r\n  // Standard room lighting\r\n  // Base darkness alphas at key stops\r\n  // Map brightness [-0.5, 0.5] to a multiplier that reduces shadow intensity\r\n  // CAP: Never let darknessMult go below 0.6 (ensures 60% darkness / 40% visibility max)\r\n  const darknessMult = Math.max(0.6, 1 - (brightness + 0.1) * 1.5);\r\n\r\n  const gradient = ctx.createRadialGradient(px, py, effectiveRadius * 0.15, px, py, effectiveRadius);\r\n  gradient.addColorStop(0, 'rgba(5, 3, 10, 0)');\r\n  gradient.addColorStop(0.3, `rgba(5, 3, 10, ${0.3 * darknessMult})`);\r\n  gradient.addColorStop(0.5, `rgba(5, 3, 10, ${0.65 * darknessMult})`);\r\n  gradient.addColorStop(0.7, `rgba(5, 3, 10, ${0.88 * darknessMult})`);\r\n  gradient.addColorStop(1, `rgba(5, 3, 10, ${0.97 * darknessMult})`);\r\n  ctx.fillStyle = gradient;\r\n  ctx.fillRect(-vp.gox, -vp.goy, vp.rw, vp.rh);\r\n}\r\n\r\nexport function renderHUD(ctx: CanvasRenderingContext2D, player: PlayerState, dungeon: DungeonMap, time: number, enemyCount: number, tutorialTimer: number, isMobile: boolean = false, vp: Viewport = { gox: 0, goy: 0, rw: C.dims.gw, rh: C.dims.gh }) {\r\n  // Mobile scale factor for bigger, readable text\r\n  const ms = isMobile ? 1.7 : 1; // mobile scale\r\n  // Viewport edges in game-translated coordinates\r\n  const visLeft = -vp.gox;\r\n  const visTop = -vp.goy;\r\n  const visRight = vp.rw - vp.gox;\r\n  const visBottom = vp.rh - vp.goy;\r\n\r\n  // --- Player HP & Resources ---\r\n  const hpW = Math.round(100 * ms);\r\n  const hpH = Math.round(10 * ms);\r\n  const hpX = visLeft + 6;\r\n  const hpY = visTop + 6;\r\n\r\n  // Background\r\n  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\r\n  ctx.fillRect(hpX, hpY, hpW, hpH);\r\n  ctx.strokeStyle = '#666666';\r\n  ctx.lineWidth = 1;\r\n  ctx.strokeRect(hpX, hpY, hpW, hpH);\r\n\r\n  // Fill\r\n  const hpPct = Math.max(0, player.hp / player.maxHp);\r\n  ctx.fillStyle = hpPct > 0.3 ? C.COLORS.hpFill : '#ff4400';\r\n  ctx.fillRect(hpX + 1, hpY + 1, Math.round((hpW - 2) * hpPct), hpH - 2);\r\n\r\n  // Text\r\n  ctx.font = `500 ${Math.round(11 * ms)}px ${C.HUD_FONT}`;\r\n  ctx.textAlign = 'left';\r\n  drawHudText(ctx, `${Math.ceil(player.hp)}/${player.maxHp}`, hpX + 2, hpY + Math.round(hpH * 0.75), '#ffffff');\r\n\r\n  // --- Potions ---\r\n  const potY = hpY + hpH + 5;\r\n  for (let i = 0; i < player.maxPotions; i++) {\r\n    const px = visLeft + 6 + i * 14;\r\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';\r\n    ctx.fillRect(px, potY, 12, 12);\r\n    ctx.strokeStyle = '#555555';\r\n    ctx.strokeRect(px, potY, 12, 12);\r\n\r\n    if (i < player.potions) {\r\n      // Potion liquid\r\n      ctx.fillStyle = '#55ff55';\r\n      ctx.fillRect(px + 3, potY + 4, 6, 6);\r\n      ctx.fillRect(px + 4, potY + 3, 4, 1);\r\n      // Shine\r\n      ctx.fillStyle = '#ffffff';\r\n      ctx.globalAlpha = 0.6;\r\n      ctx.fillRect(px + 4, potY + 5, 2, 2);\r\n      ctx.globalAlpha = 1;\r\n    } else {\r\n      // Empty slot\r\n      ctx.fillStyle = '#333333';\r\n      ctx.font = '9px monospace';\r\n      ctx.fillText('x', px + 3, potY + 9);\r\n    }\r\n  }\r\n\r\n  // --- XP Bar ---\r\n  const xpY = potY + 16;\r\n  const xpH = Math.round(5 * ms);\r\n  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\r\n  ctx.fillRect(visLeft + 6, xpY, hpW, xpH + 4);\r\n  ctx.fillStyle = C.COLORS.xpBg;\r\n  ctx.fillRect(visLeft + 8, xpY + 2, hpW - 4, xpH);\r\n  ctx.fillStyle = C.COLORS.xpFill;\r\n  ctx.fillRect(visLeft + 8, xpY + 2, (hpW - 4) * (player.xp / player.xpToNext), xpH);\r\n  ctx.fillStyle = '#88ffaa';\r\n  ctx.font = `500 ${Math.round(8 * ms)}px ${C.HUD_FONT}`;\r\n  ctx.fillText('XP', visLeft + 9, xpY + 2 + Math.round(xpH * 0.8));\r\n\r\n  // --- Soul Counter (next to level) ---\r\n  const lvlX = hpW + 14;\r\n  const soulW = Math.round(70 * ms);\r\n  const soulH = Math.round(20 * ms);\r\n  ctx.fillStyle = 'rgba(10, 15, 35, 0.85)';\r\n  ctx.fillRect(lvlX, hpY, soulW, soulH);\r\n  ctx.strokeStyle = 'rgba(80, 140, 220, 0.7)';\r\n  ctx.lineWidth = 1;\r\n  ctx.strokeRect(lvlX, hpY, soulW, soulH);\r\n  // Soul crystal icon ÔÇö draw a small diamond shape\r\n  const scx = lvlX + 10;\r\n  const scy = hpY + soulH / 2;\r\n  const scSize = Math.round(4 * ms);\r\n  ctx.fillStyle = '#6a0dad'; // Dimensional Glow Purple\r\n  ctx.beginPath();\r\n  ctx.moveTo(scx, scy - scSize);\r\n  ctx.lineTo(scx + scSize * 0.7, scy);\r\n  ctx.lineTo(scx, scy + scSize);\r\n  ctx.lineTo(scx - scSize * 0.7, scy);\r\n  ctx.closePath();\r\n  ctx.fill();\r\n  // Inner bright core\r\n  ctx.fillStyle = '#ac4dff'; // Glow Light\r\n  ctx.beginPath();\r\n  ctx.moveTo(scx, scy - scSize * 0.5);\r\n  ctx.lineTo(scx + scSize * 0.35, scy);\r\n  ctx.lineTo(scx, scy + scSize * 0.5);\r\n  ctx.lineTo(scx - scSize * 0.35, scy);\r\n  ctx.closePath();\r\n  ctx.fill();\r\n  // Soul count\r\n  ctx.font = `600 ${Math.round(10 * ms)}px ${C.HUD_FONT}`;\r\n  ctx.textAlign = 'left';\r\n  drawHudText(ctx, `${Math.floor(player.souls)}`, scx + scSize + 4, hpY + Math.round(soulH * 0.7), '#ac4dff');\r\n\r\n  // --- Level Badge ---\r\n  const lvlBadgeX = lvlX + soulW + 4;\r\n  const lvlW = Math.round(44 * ms);\r\n  const lvlH = Math.round(20 * ms);\r\n  ctx.fillStyle = 'rgba(20, 20, 60, 0.85)';\r\n  ctx.fillRect(lvlBadgeX, hpY, lvlW, lvlH);\r\n  ctx.strokeStyle = '#ac4dff';\r\n  ctx.lineWidth = 1;\r\n  ctx.strokeRect(lvlBadgeX, hpY, lvlW, lvlH);\r\n  ctx.font = `500 ${Math.round(11 * ms)}px ${C.HUD_FONT}`;\r\n  ctx.textAlign = 'left';\r\n  drawHudText(ctx, `Nv.${player.level}`, lvlBadgeX + 4, hpY + Math.round(lvlH * 0.7), '#ccaaee');\r\n\r\n  // --- Floor indicator (top-right) ---\r\n  const floorW = Math.round(84 * ms);\r\n  const floorH = Math.round(18 * ms);\r\n  const biome = getBiome(dungeon.floor);\r\n\r\n  // Biome name (small, above floor)\r\n  ctx.font = `600 ${Math.round(7 * ms)}px ${C.HUD_FONT}`;\r\n  ctx.textAlign = 'right';\r\n  drawHudText(ctx, biome.name.toUpperCase(), visRight - 6, hpY - 2, biome.accent);\r\n\r\n  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\r\n  ctx.fillRect(visRight - floorW - 6, hpY, floorW, floorH);\r\n  ctx.strokeStyle = '#aa8833';\r\n  ctx.lineWidth = 1;\r\n  ctx.strokeRect(visRight - floorW - 6, hpY, floorW, floorH);\r\n  ctx.font = `500 ${Math.round(12 * ms)}px ${C.HUD_FONT}`;\r\n  ctx.textAlign = 'left';\r\n  drawHudText(ctx, `Andar ${dungeon.floor}`, visRight - floorW - 2, hpY + Math.round(floorH * 0.72), '#ffddaa');\r\n\r\n  // --- Enemy counter ---\r\n  const ecY = hpY + floorH + 2;\r\n  const ecH = Math.round(16 * ms);\r\n  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\r\n  ctx.fillRect(visRight - floorW - 6, ecY, floorW, ecH);\r\n  if (enemyCount > 0) {\r\n    ctx.font = `500 ${Math.round(11 * ms)}px ${C.HUD_FONT}`;\r\n    ctx.textAlign = 'left';\r\n    drawHudText(ctx, `${enemyCount} inimigos`, visRight - floorW - 2, ecY + Math.round(ecH * 0.75), '#ff6644');\r\n  } else {\r\n    ctx.font = `500 ${Math.round(11 * ms)}px ${C.HUD_FONT}`;\r\n    ctx.textAlign = 'left';\r\n    drawHudText(ctx, `Sala limpa!`, visRight - floorW - 2, ecY + Math.round(ecH * 0.75), '#44ff66');\r\n  }\r\n\r\n  // --- Objective text (center top, big and clear) ---\r\n  const room = getCurrentRoom(dungeon);\r\n  if (!room) return; // Safety guard\r\n  ctx.textAlign = 'center';\r\n  const objFontSize = Math.round(isMobile ? 16 : 12);\r\n  const objBarH = Math.round(isMobile ? 26 : 18);\r\n  if (enemyCount > 0) {\r\n    const objText = room.isBossRoom ? 'DERROTE O BOSS!' :\r\n      room.type === 'trap' ? 'ÔÜá CUIDADO COM O CH├âO ÔÜá' :\r\n        room.type === 'treasure' ? 'PROTEJA O TESOURO!' : 'Elimine todos os inimigos!';\r\n    const objColor = room.isBossRoom ? '#ff4444' : room.type === 'trap' ? '#ff6644' : '#ffcc44';\r\n    const objW = Math.round(240 * ms);\r\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';\r\n    ctx.fillRect(C.dims.gw / 2 - objW / 2, 4, objW, objBarH);\r\n    ctx.font = `500 ${objFontSize}px ${C.HUD_FONT}`;\r\n    ctx.textAlign = 'center';\r\n    drawHudText(ctx, objText, C.dims.gw / 2, 4 + Math.round(objBarH * 0.75), objColor);\r\n  } else if (room.cleared) {\r\n    const pulse = Math.sin(time * 5) * 0.3 + 0.7;\r\n    // Special objective for boss victory (portal spawned)\r\n    if (room.isBossRoom) {\r\n      const boxW = Math.round(260 * ms);\r\n      ctx.fillStyle = `rgba(30, 0, 50, ${0.7 * pulse})`;\r\n      ctx.fillRect(C.dims.gw / 2 - boxW / 2, 2, boxW, objBarH + 4);\r\n      ctx.fillStyle = `rgba(200, 100, 255, ${pulse})`;\r\n      ctx.font = `600 ${objFontSize}px ${C.HUD_FONT}`;\r\n      ctx.textAlign = 'center';\r\n      drawHudText(ctx, 'ENTRE NA FENDA DIMENSIONAL', C.dims.gw / 2, 2 + Math.round((objBarH + 4) * 0.75), `rgba(200, 100, 255, ${pulse})`, 1.2);\r\n    } else if (room.type === 'shrine' && !room.shrineUsed) {\r\n      const boxW = Math.round(280 * ms);\r\n      ctx.fillStyle = `rgba(40, 20, 60, ${0.8 * pulse})`;\r\n      ctx.fillRect(C.dims.gw / 2 - boxW / 2, 2, boxW, objBarH + 4);\r\n      ctx.fillStyle = `rgba(180, 130, 255, ${pulse})`;\r\n      ctx.font = `500 ${objFontSize}px ${C.HUD_FONT}`;\r\n      ctx.fillText(isMobile ? 'ANDE AT├ë O SANTU├üRIO' : 'ANDE AT├ë O SANTU├üRIO (risco/recompensa)', C.dims.gw / 2, 2 + Math.round((objBarH + 4) * 0.72));\r\n    } else if (room.type === 'treasure' && !room.treasureCollected) {\r\n      const boxW = Math.round(240 * ms);\r\n      ctx.fillStyle = `rgba(60, 40, 0, ${0.8 * pulse})`;\r\n      ctx.fillRect(C.dims.gw / 2 - boxW / 2, 2, boxW, objBarH + 4);\r\n      ctx.fillStyle = `rgba(255, 200, 50, ${pulse})`;\r\n      ctx.font = `500 ${objFontSize}px ${C.HUD_FONT}`;\r\n      ctx.fillText('ANDE AT├ë O BA├Ü PARA COLETAR', C.dims.gw / 2, 2 + Math.round((objBarH + 4) * 0.72));\r\n    }\r\n  }\r\n  ctx.textAlign = 'left';\r\n\r\n  // --- Dash cooldown ---\r\n  if (!isMobile) {\r\n    const dashReady = player.dashCooldown <= 0;\r\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';\r\n    ctx.fillRect(6, 30, 50, 14);\r\n    ctx.fillStyle = dashReady ? '#44aaff' : '#333355';\r\n    ctx.font = `500 9px ${C.HUD_FONT}`;\r\n    ctx.fillText(dashReady ? '[F] Dash' : '[F] ...', 10, 40);\r\n    if (!dashReady) {\r\n      const pct = 1 - (player.dashCooldown / C.PLAYER_DASH_COOLDOWN);\r\n      ctx.fillStyle = '#2255aa';\r\n      ctx.fillRect(6, 43, 50 * pct, 2);\r\n    }\r\n  } else {\r\n    // Mobile: show dash cooldown bar below XP\r\n    const dashReady = player.dashCooldown <= 0;\r\n    if (!dashReady) {\r\n      const dashBarY = xpY + xpH + 6;\r\n      const pct = 1 - (player.dashCooldown / C.PLAYER_DASH_COOLDOWN);\r\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\r\n      ctx.fillRect(hpX, dashBarY, Math.round(60 * ms), Math.round(4 * ms));\r\n      ctx.fillStyle = '#2255aa';\r\n      ctx.fillRect(hpX, dashBarY, Math.round(60 * ms) * pct, Math.round(4 * ms));\r\n    }\r\n  }\r\n\r\n  // --- Upgrade icons (bottom-left) ---\r\n  const iconSize = Math.round(10 * ms);\r\n  const iconY = visBottom - Math.round(18 * ms);\r\n  for (let i = 0; i < Math.min(player.upgrades.length, 16); i++) {\r\n    ctx.fillStyle = 'rgba(30, 30, 50, 0.7)';\r\n    ctx.fillRect(visLeft + 6 + i * (iconSize + 2), iconY, iconSize, iconSize);\r\n    ctx.fillStyle = C.COLORS.common;\r\n    ctx.fillRect(visLeft + 7 + i * (iconSize + 2), iconY + 1, iconSize - 2, iconSize - 2);\r\n  }\r\n\r\n  // --- Minimap ---\r\n  // On mobile landscape, position minimap at bottom-left to avoid button overlap\r\n  renderMinimap(ctx, dungeon, isMobile, vp);\r\n\r\n  // --- Time ---\r\n  const mins = Math.floor(time / 60);\r\n  const secs = Math.floor(time % 60);\r\n  ctx.fillStyle = 'rgba(200, 200, 200, 0.5)';\r\n  ctx.font = `${Math.round(8 * ms)}px ${C.HUD_FONT}`;\r\n  const timeX = isMobile ? visLeft + 6 : visRight - 40;\r\n  const timeY = isMobile ? visBottom - Math.round(22 * ms) : visBottom - 6;\r\n  ctx.fillText(`${mins}:${secs.toString().padStart(2, '0')}`, timeX, timeY);\r\n\r\n  // Tutorial overlay removed ÔÇö menu now explains controls\r\n\r\n  // --- Bottom control hints (desktop only) ---\r\n  if (!isMobile && tutorialTimer <= 0) {\r\n    ctx.fillStyle = 'rgba(0,0,0,0.5)';\r\n    ctx.fillRect(visLeft, visBottom - 14, vp.rw, 14);\r\n    ctx.fillStyle = 'rgba(180, 180, 200, 0.5)';\r\n    ctx.font = `8px ${C.HUD_FONT}`;\r\n    ctx.textAlign = 'center';\r\n    ctx.fillText('WASD: Mover  Ôöé  Clique: Atacar  Ôöé  Clique Dir: Proj├®til  Ôöé  F: Dash', C.dims.gw / 2, visBottom - 4);\r\n    ctx.textAlign = 'left';\r\n  }\r\n}\r\n\r\nfunction renderMinimap(ctx: CanvasRenderingContext2D, dungeon: DungeonMap, isMobile: boolean = false, vp: Viewport = { gox: 0, goy: 0, rw: C.dims.gw, rh: C.dims.gh }) {\r\n  const cellSize = 18;\r\n  const gap = 8;\r\n  const connW = 5;\r\n  const step = cellSize + gap;\r\n  const visRight = vp.rw - vp.gox;\r\n  const visBottom = vp.rh - vp.goy;\r\n  const visLeft = -vp.gox;\r\n\r\n  // Find bounds of the dungeon grid\r\n  let minGX = Infinity, maxGX = -Infinity, minGY = Infinity, maxGY = -Infinity;\r\n  for (const room of dungeon.rooms.values()) {\r\n    if (room.gridX < minGX) minGX = room.gridX;\r\n    if (room.gridX > maxGX) maxGX = room.gridX;\r\n    if (room.gridY < minGY) minGY = room.gridY;\r\n    if (room.gridY > maxGY) maxGY = room.gridY;\r\n  }\r\n  const cols = maxGX - minGX + 1;\r\n  const rows = maxGY - minGY + 1;\r\n  const mapW = cols * step - gap;\r\n  const mapH = rows * step - gap;\r\n  const pad = 8;\r\n  const ox = isMobile ? visLeft + pad + 6 : visRight - mapW - pad - 8;\r\n  const oy = visBottom - mapH - pad - (isMobile ? 42 : 28);\r\n\r\n  // Background panel ÔÇö brightness-reactive\r\n  const brightness = getBrightness();\r\n  const mapDarkness = Math.max(0.7, 1 - (brightness + 0.5) * 0.4);\r\n  ctx.fillStyle = `rgba(20, 22, 35, ${0.92 * mapDarkness})`;\r\n  const panelX = ox - pad;\r\n  const panelY = oy - pad - 16;\r\n  const panelW = mapW + pad * 2;\r\n  const panelH = mapH + pad * 2 + 16;\r\n  ctx.beginPath();\r\n  roundRect(ctx, panelX, panelY, panelW, panelH, 5);\r\n  ctx.fill();\r\n  ctx.strokeStyle = 'rgba(120, 130, 180, 0.5)';\r\n  ctx.lineWidth = 1;\r\n  ctx.beginPath();\r\n  roundRect(ctx, panelX, panelY, panelW, panelH, 5);\r\n  ctx.stroke();\r\n\r\n  // Title ÔÇö bigger, brighter\r\n  ctx.fillStyle = 'rgba(200, 205, 230, 0.85)';\r\n  ctx.font = `600 9px ${C.HUD_FONT}`;\r\n  ctx.textAlign = 'center';\r\n  ctx.fillText(`MAPA ÔÇö ANDAR ${dungeon.floor}`, panelX + panelW / 2, panelY + 12);\r\n  ctx.textAlign = 'left';\r\n\r\n  // Draw corridors (connections between rooms) ÔÇö brighter\r\n  ctx.lineWidth = connW;\r\n  ctx.lineCap = 'round';\r\n  for (const [, room] of dungeon.rooms) {\r\n    const rx = ox + (room.gridX - minGX) * step + cellSize / 2;\r\n    const ry = oy + (room.gridY - minGY) * step + cellSize / 2;\r\n    const visited = room.visited;\r\n\r\n    if (room.doors.east && dungeon.rooms.has(roomKey(room.gridX + 1, room.gridY))) {\r\n      const neighbor = dungeon.rooms.get(roomKey(room.gridX + 1, room.gridY));\r\n      const show = visited || neighbor?.visited;\r\n      if (show && neighbor) {\r\n        const both = visited && neighbor.visited;\r\n        ctx.strokeStyle = both ? 'rgba(100, 110, 150, 0.8)' : 'rgba(70, 75, 100, 0.4)';\r\n        ctx.beginPath();\r\n        ctx.moveTo(rx + cellSize / 2, ry);\r\n        ctx.lineTo(rx + cellSize / 2 + gap, ry);\r\n        ctx.stroke();\r\n      }\r\n    }\r\n    if (room.doors.south && dungeon.rooms.has(roomKey(room.gridX, room.gridY + 1))) {\r\n      const neighbor = dungeon.rooms.get(roomKey(room.gridX, room.gridY + 1));\r\n      const show = visited || neighbor?.visited;\r\n      if (show && neighbor) {\r\n        const both = visited && neighbor.visited;\r\n        ctx.strokeStyle = both ? 'rgba(100, 110, 150, 0.8)' : 'rgba(70, 75, 100, 0.4)';\r\n        ctx.beginPath();\r\n        ctx.moveTo(rx, ry + cellSize / 2);\r\n        ctx.lineTo(rx, ry + cellSize / 2 + gap);\r\n        ctx.stroke();\r\n      }\r\n    }\r\n  }\r\n  ctx.lineCap = 'butt';\r\n\r\n  // Draw rooms ÔÇö brighter fills and clearer borders\r\n  for (const [key, room] of dungeon.rooms) {\r\n    const isCurrent = key === dungeon.currentRoomKey;\r\n    const rx = ox + (room.gridX - minGX) * step;\r\n    const ry = oy + (room.gridY - minGY) * step;\r\n    const cx = rx + cellSize / 2;\r\n    const cy = ry + cellSize / 2;\r\n\r\n    if (!room.visited) {\r\n      // Adjacent-to-visited rooms: brighter fog of war\r\n      let adjacentVisited = false;\r\n      const dirs = [{ dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }];\r\n      for (const d of dirs) {\r\n        const nk = roomKey(room.gridX + d.dx, room.gridY + d.dy);\r\n        const nr = dungeon.rooms.get(nk);\r\n        if (nr && nr.visited) { adjacentVisited = true; break; }\r\n      }\r\n      if (adjacentVisited) {\r\n        ctx.strokeStyle = 'rgba(130, 135, 170, 0.45)';\r\n        ctx.lineWidth = 1;\r\n        ctx.setLineDash([3, 2]);\r\n        ctx.strokeRect(rx + 1, ry + 1, cellSize - 2, cellSize - 2);\r\n        ctx.setLineDash([]);\r\n        ctx.fillStyle = 'rgba(160, 165, 200, 0.5)';\r\n        ctx.font = `600 10px ${C.HUD_FONT}`;\r\n        ctx.textAlign = 'center';\r\n        ctx.fillText('?', cx, cy + 4);\r\n        ctx.textAlign = 'left';\r\n      }\r\n      continue;\r\n    }\r\n\r\n    // Room fill color ÔÇö much brighter and more distinct\r\n    let fillColor: string;\r\n    let borderColor: string;\r\n    if (isCurrent) {\r\n      fillColor = 'rgba(90, 150, 255, 0.7)';\r\n      borderColor = 'rgba(140, 190, 255, 1)';\r\n    } else if (room.isBossRoom) {\r\n      fillColor = room.cleared ? 'rgba(140, 60, 60, 0.6)' : 'rgba(220, 70, 70, 0.65)';\r\n      borderColor = 'rgba(255, 110, 110, 0.9)';\r\n    } else if (room.type === 'treasure') {\r\n      fillColor = room.treasureCollected ? 'rgba(120, 100, 50, 0.5)' : 'rgba(230, 195, 60, 0.6)';\r\n      borderColor = 'rgba(255, 225, 80, 0.9)';\r\n    } else if (room.type === 'shrine') {\r\n      fillColor = room.shrineUsed ? 'rgba(80, 50, 100, 0.5)' : 'rgba(160, 90, 230, 0.6)';\r\n      borderColor = 'rgba(200, 140, 255, 0.9)';\r\n    } else if (room.type === 'vendor') {\r\n      fillColor = 'rgba(70, 160, 110, 0.6)';\r\n      borderColor = 'rgba(120, 240, 170, 0.9)';\r\n    } else if (room.type === 'trap') {\r\n      fillColor = room.trapTriggered ? 'rgba(110, 50, 50, 0.5)' : 'rgba(220, 80, 60, 0.55)';\r\n      borderColor = 'rgba(255, 130, 100, 0.8)';\r\n    } else if (room.cleared) {\r\n      fillColor = 'rgba(60, 130, 75, 0.6)';\r\n      borderColor = 'rgba(100, 200, 120, 0.7)';\r\n    } else {\r\n      fillColor = 'rgba(85, 90, 120, 0.6)';\r\n      borderColor = 'rgba(140, 145, 180, 0.7)';\r\n    }\r\n\r\n    // Fill\r\n    ctx.fillStyle = fillColor;\r\n    ctx.beginPath();\r\n    roundRect(ctx, rx, ry, cellSize, cellSize, 3);\r\n    ctx.fill();\r\n\r\n    // Border\r\n    ctx.strokeStyle = borderColor;\r\n    ctx.lineWidth = isCurrent ? 2.5 : 1.5;\r\n    ctx.beginPath();\r\n    roundRect(ctx, rx, ry, cellSize, cellSize, 3);\r\n    ctx.stroke();\r\n\r\n    // Room icon ÔÇö bigger and clearer\r\n    ctx.textAlign = 'center';\r\n    ctx.font = `600 10px ${C.HUD_FONT}`;\r\n    if (isCurrent) {\r\n      // Player dot (pulsing)\r\n      const pulse = Math.sin(Date.now() / 200) * 2 + 4;\r\n      ctx.fillStyle = 'rgba(170, 210, 255, 0.95)';\r\n      ctx.beginPath();\r\n      ctx.arc(cx, cy, pulse, 0, Math.PI * 2);\r\n      ctx.fill();\r\n      ctx.fillStyle = '#ffffff';\r\n      ctx.beginPath();\r\n      ctx.arc(cx, cy, 2, 0, Math.PI * 2);\r\n      ctx.fill();\r\n    } else if (room.isBossRoom) {\r\n      ctx.fillStyle = room.cleared ? 'rgba(220, 130, 130, 0.6)' : 'rgba(255, 120, 100, 1)';\r\n      ctx.fillText('­ƒÆÇ', cx, cy + 4);\r\n    } else if (room.type === 'treasure') {\r\n      ctx.fillStyle = 'rgba(255, 230, 100, 1)';\r\n      ctx.fillText(room.treasureCollected ? '┬À' : 'Ôùå', cx, cy + 4);\r\n    } else if (room.type === 'shrine') {\r\n      ctx.fillStyle = 'rgba(200, 150, 255, 1)';\r\n      ctx.fillText(room.shrineUsed ? '┬À' : 'Ô£ª', cx, cy + 4);\r\n    } else if (room.type === 'vendor') {\r\n      ctx.fillStyle = 'rgba(130, 255, 200, 1)';\r\n      ctx.fillText('$', cx, cy + 4);\r\n    } else if (room.type === 'trap') {\r\n      ctx.fillStyle = 'rgba(255, 130, 90, 1)';\r\n      ctx.fillText(room.trapTriggered ? '┬À' : 'ÔÜá', cx, cy + 4);\r\n    } else if (room.cleared) {\r\n      ctx.fillStyle = 'rgba(130, 220, 145, 0.8)';\r\n      ctx.fillText('Ô£ô', cx, cy + 4);\r\n    }\r\n    ctx.textAlign = 'left';\r\n  }\r\n\r\n  // Legend ÔÇö bigger, brighter, easier to read\r\n  const legendY = panelY + panelH + 4;\r\n  ctx.font = `500 7px ${C.HUD_FONT}`;\r\n  const legends = [\r\n    { color: 'rgba(120, 170, 255, 0.95)', label: 'VOC├è' },\r\n    { color: 'rgba(100, 200, 120, 0.95)', label: 'LIMPA' },\r\n    { color: 'rgba(255, 110, 110, 0.95)', label: 'BOSS' },\r\n    { color: 'rgba(255, 225, 80, 0.95)', label: 'TESOURO' },\r\n    { color: 'rgba(120, 240, 170, 0.95)', label: 'LOJA' },\r\n  ];\r\n  let lx = panelX;\r\n  for (const l of legends) {\r\n    ctx.fillStyle = l.color;\r\n    ctx.fillRect(lx, legendY, 6, 6);\r\n    ctx.fillStyle = 'rgba(190, 195, 220, 0.8)';\r\n    ctx.fillText(l.label, lx + 8, legendY + 6);\r\n    lx += ctx.measureText(l.label).width + 14;\r\n  }\r\n}\r\n\r\n// Helper for rounded rectangles\r\nfunction roundRect(ctx: CanvasRenderingContext2D, x: number, y: number, w: number, h: number, r: number) {\r\n  ctx.moveTo(x + r, y);\r\n  ctx.lineTo(x + w - r, y);\r\n  ctx.arcTo(x + w, y, x + w, y + r, r);\r\n  ctx.lineTo(x + w, y + h - r);\r\n  ctx.arcTo(x + w, y + h, x + w - r, y + h, r);\r\n  ctx.lineTo(x + r, y + h);\r\n  ctx.arcTo(x, y + h, x, y + h - r, r);\r\n  ctx.lineTo(x, y + r);\r\n  ctx.arcTo(x, y, x + r, y, r);\r\n}\r\n\r\nexport function applyScreenEffects(ctx: CanvasRenderingContext2D, effects: ScreenEffect[], vp: Viewport) {\r\n  for (const fx of effects) {\r\n    if (fx.type === 'flash' && fx.color) {\r\n      // Intensity should multiply the peak alpha\r\n      const peakAlpha = 0.35 * fx.intensity;\r\n      const alpha = (fx.timer / fx.duration) * peakAlpha;\r\n\r\n      // Robust replace: only replace the first occurrence of rgb/rgba to avoid errors\r\n      let color = fx.color;\r\n      if (!color.includes('rgba')) {\r\n        color = color.replace('rgb', 'rgba').replace(')', `, ${alpha})`);\r\n      } else {\r\n        // If already rgba, we must be careful. For simplicity, we use globalAlpha for the whole operation\r\n        ctx.save();\r\n        ctx.globalAlpha = alpha;\r\n        ctx.fillStyle = fx.color;\r\n        ctx.fillRect(-vp.gox, -vp.goy, vp.rw, vp.rh);\r\n        ctx.restore();\r\n        continue;\r\n      }\r\n\r\n      ctx.fillStyle = color;\r\n      ctx.fillRect(-vp.gox, -vp.goy, vp.rw, vp.rh);\r\n    }\r\n  }\r\n}\r\n\r\nexport function getShakeOffset(effects: ScreenEffect[]): { x: number; y: number } {\r\n  let x = 0, y = 0;\r\n  for (const fx of effects) {\r\n    if (fx.type === 'shake') {\r\n      const intensity = fx.intensity * (fx.timer / fx.duration);\r\n      x += (Math.random() - 0.5) * intensity * 2;\r\n      y += (Math.random() - 0.5) * intensity * 2;\r\n    }\r\n  }\r\n  return { x: Math.round(x), y: Math.round(y) };\r\n}\r\n\r\n// ============ HIDDEN TRAP RENDERING ============\r\n\r\nexport function renderHiddenTraps(ctx: CanvasRenderingContext2D, traps: HiddenTrap[], time: number) {\r\n  for (const trap of traps) {\r\n    if (trap.triggered) {\r\n      // Show activated trap mark\r\n      ctx.fillStyle = 'rgba(255, 0, 0, 0.15)';\r\n      ctx.beginPath();\r\n      ctx.arc(trap.x, trap.y, C.TILE_SIZE * 0.6, 0, Math.PI * 2);\r\n      ctx.fill();\r\n      continue;\r\n    }\r\n\r\n    // RED tile hint ÔÇö clearly different but player must still pay attention\r\n    const tileX = trap.x - C.TILE_SIZE / 2;\r\n    const tileY = trap.y - C.TILE_SIZE / 2;\r\n\r\n    // Dark red tile overlay\r\n    ctx.fillStyle = 'rgba(120, 20, 20, 0.25)';\r\n    ctx.fillRect(tileX, tileY, C.TILE_SIZE, C.TILE_SIZE);\r\n\r\n    // Subtle red border\r\n    ctx.strokeStyle = 'rgba(180, 30, 30, 0.2)';\r\n    ctx.lineWidth = 0.5;\r\n    ctx.strokeRect(tileX + 1, tileY + 1, C.TILE_SIZE - 2, C.TILE_SIZE - 2);\r\n\r\n    // Small red crack/mark\r\n    const seed = trap.hintSeed;\r\n    const markType = Math.floor(seed) % 3;\r\n    ctx.strokeStyle = 'rgba(150, 30, 30, 0.3)';\r\n    ctx.lineWidth = 0.5;\r\n    ctx.beginPath();\r\n    if (markType === 0) {\r\n      ctx.moveTo(trap.x - 4, trap.y - 3);\r\n      ctx.lineTo(trap.x + 3, trap.y + 4);\r\n    } else if (markType === 1) {\r\n      ctx.moveTo(trap.x - 3, trap.y);\r\n      ctx.lineTo(trap.x + 4, trap.y + 1);\r\n    } else {\r\n      ctx.moveTo(trap.x, trap.y - 4);\r\n      ctx.lineTo(trap.x + 1, trap.y + 4);\r\n    }\r\n    ctx.stroke();\r\n  }\r\n}\r\n\r\n// ============ TRAP EFFECT OVERLAYS ============\r\n\r\nexport function renderTrapEffectOverlay(\r\n  ctx: CanvasRenderingContext2D,\r\n  time: number,\r\n  panicTimer: number,\r\n  lightsOutTimer: number,\r\n  doorsLockedTimer: number,\r\n  vp: Viewport,\r\n) {\r\n  const fx = -vp.gox;\r\n  const fy = -vp.goy;\r\n  const fw = vp.rw;\r\n  const fh = vp.rh;\r\n  // Panic effect ÔÇö distortion, flashing, chaos\r\n  if (panicTimer > 0) {\r\n    const intensity = Math.min(1, panicTimer / 2);\r\n    // Red/purple flashing\r\n    const flash = Math.sin(time * 25) * 0.15 * intensity;\r\n    ctx.fillStyle = `rgba(200, 0, 50, ${Math.abs(flash)})`;\r\n    ctx.fillRect(fx, fy, fw, fh);\r\n    // Chromatic aberration simulation\r\n    const offset = Math.sin(time * 30) * 3 * intensity;\r\n    ctx.fillStyle = `rgba(0, 255, 0, ${0.03 * intensity})`;\r\n    ctx.fillRect(fx + offset, fy, fw, fh);\r\n    ctx.fillStyle = `rgba(255, 0, 255, ${0.03 * intensity})`;\r\n    ctx.fillRect(fx - offset, fy, fw, fh);\r\n    // Scan lines\r\n    for (let y = fy; y < fy + fh; y += 4) {\r\n      ctx.fillStyle = `rgba(0, 0, 0, ${0.08 * intensity * (Math.sin(y + time * 50) > 0 ? 1 : 0)})`;\r\n      ctx.fillRect(fx, y, fw, 2);\r\n    }\r\n  }\r\n\r\n  // Lights out ÔÇö near total darkness overlay\r\n  if (lightsOutTimer > 0) {\r\n    const alpha = Math.min(0.95, lightsOutTimer > 1 ? 0.95 : lightsOutTimer * 0.95);\r\n    ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;\r\n    ctx.fillRect(fx, fy, fw, fh);\r\n  }\r\n\r\n  // Doors locked indicator\r\n  if (doorsLockedTimer > 0) {\r\n    const pulse = Math.sin(time * 6) * 0.3 + 0.7;\r\n    ctx.strokeStyle = `rgba(255, 0, 0, ${0.3 * pulse})`;\r\n    ctx.lineWidth = 3;\r\n  }\r\n}\r\n\r\n/**\r\n * Biome Ambient Screen Effects: Full-screen immersion layers\r\n */\r\nexport function renderBiomeAmbientFX(ctx: CanvasRenderingContext2D, time: number, floor: number, vp: Viewport) {\r\n  const biome = getBiome(floor);\r\n  const { rw, rh, gox, goy } = vp;\r\n\r\n  // We render relative to screen space, so we use absolute viewport sizes\r\n  // but we need to offset back from the global arena transform if we are inside a save/translate\r\n  // However, calling this after all arena elements is best.\r\n\r\n  ctx.save();\r\n  // Ensure we are in screen coordinates (undoing the gox/goy translate if needed)\r\n  // But usually called outside the shake/translate.\r\n\r\n  if (biome.theme === 'crystal') {\r\n    // 1. FROST VIGNETTE\r\n    const fGrad = ctx.createRadialGradient(rw / 2, rh / 2, rh / 3, rw / 2, rh / 2, rh / 1.2);\r\n    fGrad.addColorStop(0, 'rgba(0,0,0,0)');\r\n    fGrad.addColorStop(1, 'rgba(200, 240, 255, 0.15)');\r\n    ctx.fillStyle = fGrad;\r\n    ctx.fillRect(-gox, -goy, rw, rh);\r\n\r\n    // 2. FLOATING ICE SHARDS\r\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';\r\n    for (let i = 0; i < 15; i++) {\r\n      const h = (i * 137 + time * 15) % rw - gox;\r\n      const v = (i * 253 + time * 10) % rh - goy;\r\n      ctx.fillRect(h, v, 2, 2);\r\n    }\r\n  }\r\n  else if (biome.theme === 'forest') {\r\n    // 1. GLOWING SPORES\r\n    ctx.fillStyle = biome.accentGlow.replace(/[\\d.]+\\)$/, '0.4)');\r\n    for (let i = 0; i < 20; i++) {\r\n      const h = (i * 91 + Math.sin(time * 0.5 + i) * 20) % rw - gox;\r\n      const v = (i * 123 - time * 12) % rh - goy;\r\n      const s = 1 + (i % 2);\r\n      ctx.beginPath();\r\n      ctx.arc(h, v, s, 0, Math.PI * 2);\r\n      ctx.fill();\r\n    }\r\n  }\r\n  else if (biome.theme === 'volcano') {\r\n    // 1. HEAT PULSE\r\n    const heatAlpha = 0.04 + Math.sin(time * 3) * 0.02;\r\n    ctx.fillStyle = `rgba(255, 80, 0, ${heatAlpha})`;\r\n    ctx.fillRect(-gox, -goy, rw, rh);\r\n\r\n    // 2. RISING ASH EMBERS\r\n    for (let i = 0; i < 25; i++) {\r\n      const h = (i * 157 + Math.sin(time + i) * 15) % rw - gox;\r\n      const v = (i * 211 - time * 60) % rh - goy;\r\n      const glow = 0.5 + Math.random() * 0.5;\r\n      ctx.fillStyle = `rgba(255, 180, 50, ${glow})`;\r\n      ctx.fillRect(h, v, 1.5, 1.5);\r\n    }\r\n  }\r\n\r\n  ctx.restore();\r\n}\r\n","usedDeprecatedRules":[]}]
